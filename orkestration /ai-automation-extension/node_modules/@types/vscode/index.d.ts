/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License.
 *  See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

/**
 * Type Definition for Visual Studio Code 1.105 Extension API
 * See https://code.visualstudio.com/api for more information
 */

declare module 'vscode' {

	/**
	 * The version of the editor.
	 */
	export const version: string;

	/**
	 * Represents a reference to a command. Provides a title which
	 * will be used to represent a command in the UI and, optionally,
	 * an array of arguments which will be passed to the command handler
	 * function when invoked.
	 */
	export interface Command {
		/**
		 * Title of the command, like `save`.
		 */
		title: string;

		/**
		 * The identifier of the actual command handler.
		 * @see {@link commands.registerCommand}
		 */
		command: string;

		/**
		 * A tooltip for the command, when represented in the UI.
		 */
		tooltip?: string;

		/**
		 * Arguments that the command handler should be
		 * invoked with.
		 */
		arguments?: any[];
	}

	/**
	 * Represents a line of text, such as a line of source code.
	 *
	 * TextLine objects are __immutable__. When a {@link TextDocument document} changes,
	 * previously retrieved lines will not represent the latest state.
	 */
	export interface TextLine {

		/**
		 * The zero-based line number.
		 */
		readonly lineNumber: number;

		/**
		 * The text of this line without the line separator characters.
		 */
		readonly text: string;

		/**
		 * The range this line covers without the line separator characters.
		 */
		readonly range: Range;

		/**
		 * The range this line covers with the line separator characters.
		 */
		readonly rangeIncludingLineBreak: Range;

		/**
		 * The offset of the first character which is not a whitespace character as defined
		 * by `/\s/`. **Note** that if a line is all whitespace the length of the line is returned.
		 */
		readonly firstNonWhitespaceCharacterIndex: number;

		/**
		 * Whether this line is whitespace only, shorthand
		 * for {@link TextLine.firstNonWhitespaceCharacterIndex} === {@link TextLine.text TextLine.text.length}.
		 */
		readonly isEmptyOrWhitespace: boolean;
	}

	/**
	 * Represents a text document, such as a source file. Text documents have
	 * {@link TextLine lines} and knowledge about an underlying resource like a file.
	 */
	export interface TextDocument {

		/**
		 * The associated uri for this document.
		 *
		 * *Note* that most documents use the `file`-scheme, which means they are files on disk. However, **not** all documents are
		 * saved on disk and therefore the `scheme` must be checked before trying to access the underlying file or siblings on disk.
		 *
		 * @see {@link FileSystemProvider}
		 * @see {@link TextDocumentContentProvider}
		 */
		readonly uri: Uri;

		/**
		 * The file system path of the associated resource. Shorthand
		 * notation for {@link TextDocument.uri TextDocument.uri.fsPath}. Independent of the uri scheme.
		 */
		readonly fileName: string;

		/**
		 * Is this document representing an untitled file which has never been saved yet. *Note* that
		 * this does not mean the document will be saved to disk, use {@linkcode Uri.scheme}
		 * to figure out where a document will be {@link FileSystemProvider saved}, e.g. `file`, `ftp` etc.
		 */
		readonly isUntitled: boolean;

		/**
		 * The identifier of the language associated with this document.
		 */
		readonly languageId: string;

		/**
		 * The file encoding of this document that will be used when the document is saved.
		 *
		 * Use the {@link workspace.onDidChangeTextDocument onDidChangeTextDocument}-event to
		 * get notified when the document encoding changes.
		 *
		 * Note that the possible encoding values are currently defined as any of the following:
		 * 'utf8', 'utf8bom', 'utf16le', 'utf16be', 'windows1252', 'iso88591', 'iso88593',
		 * 'iso885915', 'macroman', 'cp437', 'windows1256', 'iso88596', 'windows1257',
		 * 'iso88594', 'iso885914', 'windows1250', 'iso88592', 'cp852', 'windows1251',
		 * 'cp866', 'cp1125', 'iso88595', 'koi8r', 'koi8u', 'iso885913', 'windows1253',
		 * 'iso88597', 'windows1255', 'iso88598', 'iso885910', 'iso885916', 'windows1254',
		 * 'iso88599', 'windows1258', 'gbk', 'gb18030', 'cp950', 'big5hkscs', 'shiftjis',
		 * 'eucjp', 'euckr', 'windows874', 'iso885911', 'koi8ru', 'koi8t', 'gb2312',
		 * 'cp865', 'cp850'.
		 */
		readonly encoding: string;

		/**
		 * The version number of this document (it will strictly increase after each
		 * change, including undo/redo).
		 */
		readonly version: number;

		/**
		 * `true` if there are unpersisted changes.
		 */
		readonly isDirty: boolean;

		/**
		 * `true` if the document has been closed. A closed document isn't synchronized anymore
		 * and won't be re-used when the same resource is opened again.
		 */
		readonly isClosed: boolean;

		/**
		 * Save the underlying file.
		 *
		 * @returns A promise that will resolve to `true` when the file
		 * has been saved. If the save failed, will return `false`.
		 */
		save(): Thenable<boolean>;

		/**
		 * The {@link EndOfLine end of line} sequence that is predominately
		 * used in this document.
		 */
		readonly eol: EndOfLine;

		/**
		 * The number of lines in this document.
		 */
		readonly lineCount: number;

		/**
		 * Returns a text line denoted by the line number. Note
		 * that the returned object is *not* live and changes to the
		 * document are not reflected.
		 *
		 * @param line A line number in `[0, lineCount)`.
		 * @returns A {@link TextLine line}.
		 */
		lineAt(line: number): TextLine;

		/**
		 * Returns a text line denoted by the position. Note
		 * that the returned object is *not* live and changes to the
		 * document are not reflected.
		 *
		 * The position will be {@link TextDocument.validatePosition adjusted}.
		 *
		 * @see {@link TextDocument.lineAt}
		 *
		 * @param position A position.
		 * @returns A {@link TextLine line}.
		 */
		lineAt(position: Position): TextLine;

		/**
		 * Converts the position to a zero-based offset.
		 *
		 * The position will be {@link TextDocument.validatePosition adjusted}.
		 *
		 * @param position A position.
		 * @returns A valid zero-based offset in UTF-16 [code units](https://developer.mozilla.org/en-US/docs/Glossary/Code_unit).
		 */
		offsetAt(position: Position): number;

		/**
		 * Converts a zero-based offset to a position.
		 *
		 * @param offset A zero-based offset into the document. This offset is in UTF-16 [code units](https://developer.mozilla.org/en-US/docs/Glossary/Code_unit).
		 * @returns A valid {@link Position}.
		 */
		positionAt(offset: number): Position;

		/**
		 * Get the text of this document. A substring can be retrieved by providing
		 * a range. The range will be {@link TextDocument.validateRange adjusted}.
		 *
		 * @param range Include only the text included by the range.
		 * @returns The text inside the provided range or the entire text.
		 */
		getText(range?: Range): string;

		/**
		 * Get a word-range at the given position. By default words are defined by
		 * common separators, like space, -, _, etc. In addition, per language custom
		 * [word definitions] can be defined. It
		 * is also possible to provide a custom regular expression.
		 *
		 * * *Note 1:* A custom regular expression must not match the empty string and
		 * if it does, it will be ignored.
		 * * *Note 2:* A custom regular expression will fail to match multiline strings
		 * and in the name of speed regular expressions should not match words with
		 * spaces. Use {@linkcode TextLine.text} for more complex, non-wordy, scenarios.
		 *
		 * The position will be {@link TextDocument.validatePosition adjusted}.
		 *
		 * @param position A position.
		 * @param regex Optional regular expression that describes what a word is.
		 * @returns A range spanning a word, or `undefined`.
		 */
		getWordRangeAtPosition(position: Position, regex?: RegExp): Range | undefined;

		/**
		 * Ensure a range is completely contained in this document.
		 *
		 * @param range A range.
		 * @returns The given range or a new, adjusted range.
		 */
		validateRange(range: Range): Range;

		/**
		 * Ensure a position is contained in the range of this document.
		 *
		 * @param position A position.
		 * @returns The given position or a new, adjusted position.
		 */
		validatePosition(position: Position): Position;
	}

	/**
	 * Represents a line and character position, such as
	 * the position of the cursor.
	 *
	 * Position objects are __immutable__. Use the {@link Position.with with} or
	 * {@link Position.translate translate} methods to derive new positions
	 * from an existing position.
	 */
	export class Position {

		/**
		 * The zero-based line value.
		 */
		readonly line: number;

		/**
		 * The zero-based character value.
		 *
		 * Character offsets are expressed using UTF-16 [code units](https://developer.mozilla.org/en-US/docs/Glossary/Code_unit).
		 */
		readonly character: number;

		/**
		 * @param line A zero-based line value.
		 * @param character A zero-based character value.
		 */
		constructor(line: number, character: number);

		/**
		 * Check if this position is before `other`.
		 *
		 * @param other A position.
		 * @returns `true` if position is on a smaller line
		 * or on the same line on a smaller character.
		 */
		isBefore(other: Position): boolean;

		/**
		 * Check if this position is before or equal to `other`.
		 *
		 * @param other A position.
		 * @returns `true` if position is on a smaller line
		 * or on the same line on a smaller or equal character.
		 */
		isBeforeOrEqual(other: Position): boolean;

		/**
		 * Check if this position is after `other`.
		 *
		 * @param other A position.
		 * @returns `true` if position is on a greater line
		 * or on the same line on a greater character.
		 */
		isAfter(other: Position): boolean;

		/**
		 * Check if this position is after or equal to `other`.
		 *
		 * @param other A position.
		 * @returns `true` if position is on a greater line
		 * or on the same line on a greater or equal character.
		 */
		isAfterOrEqual(other: Position): boolean;

		/**
		 * Check if this position is equal to `other`.
		 *
		 * @param other A position.
		 * @returns `true` if the line and character of the given position are equal to
		 * the line and character of this position.
		 */
		isEqual(other: Position): boolean;

		/**
		 * Compare this to `other`.
		 *
		 * @param other A position.
		 * @returns A number smaller than zero if this position is before the given position,
		 * a number greater than zero if this position is after the given position, or zero when
		 * this and the given position are equal.
		 */
		compareTo(other: Position): number;

		/**
		 * Create a new position relative to this position.
		 *
		 * @param lineDelta Delta value for the line value, default is `0`.
		 * @param characterDelta Delta value for the character value, default is `0`.
		 * @returns A position which line and character is the sum of the current line and
		 * character and the corresponding deltas.
		 */
		translate(lineDelta?: number, characterDelta?: number): Position;

		/**
		 * Derived a new position relative to this position.
		 *
		 * @param change An object that describes a delta to this position.
		 * @returns A position that reflects the given delta. Will return `this` position if the change
		 * is not changing anything.
		 */
		translate(change: {
			/**
			 * Delta value for the line value, default is `0`.
			 */
			lineDelta?: number;
			/**
			 * Delta value for the character value, default is `0`.
			 */
			characterDelta?: number;
		}): Position;

		/**
		 * Create a new position derived from this position.
		 *
		 * @param line Value that should be used as line value, default is the {@link Position.line existing value}
		 * @param character Value that should be used as character value, default is the {@link Position.character existing value}
		 * @returns A position where line and character are replaced by the given values.
		 */
		with(line?: number, character?: number): Position;

		/**
		 * Derived a new position from this position.
		 *
		 * @param change An object that describes a change to this position.
		 * @returns A position that reflects the given change. Will return `this` position if the change
		 * is not changing anything.
		 */
		with(change: {
			/**
			 * New line value, defaults the line value of `this`.
			 */
			line?: number;
			/**
			 * New character value, defaults the character value of `this`.
			 */
			character?: number;
		}): Position;
	}

	/**
	 * A range represents an ordered pair of two positions.
	 * It is guaranteed that {@link Range.start start}.isBeforeOrEqual({@link Range.end end})
	 *
	 * Range objects are __immutable__. Use the {@link Range.with with},
	 * {@link Range.intersection intersection}, or {@link Range.union union} methods
	 * to derive new ranges from an existing range.
	 */
	export class Range {

		/**
		 * The start position. It is before or equal to {@link Range.end end}.
		 */
		readonly start: Position;

		/**
		 * The end position. It is after or equal to {@link Range.start start}.
		 */
		readonly end: Position;

		/**
		 * Create a new range from two positions. If `start` is not
		 * before or equal to `end`, the values will be swapped.
		 *
		 * @param start A position.
		 * @param end A position.
		 */
		constructor(start: Position, end: Position);

		/**
		 * Create a new range from number coordinates. It is a shorter equivalent of
		 * using `new Range(new Position(startLine, startCharacter), new Position(endLine, endCharacter))`
		 *
		 * @param startLine A zero-based line value.
		 * @param startCharacter A zero-based character value.
		 * @param endLine A zero-based line value.
		 * @param endCharacter A zero-based character value.
		 */
		constructor(startLine: number, startCharacter: number, endLine: number, endCharacter: number);

		/**
		 * `true` if `start` and `end` are equal.
		 */
		isEmpty: boolean;

		/**
		 * `true` if `start.line` and `end.line` are equal.
		 */
		isSingleLine: boolean;

		/**
		 * Check if a position or a range is contained in this range.
		 *
		 * @param positionOrRange A position or a range.
		 * @returns `true` if the position or range is inside or equal
		 * to this range.
		 */
		contains(positionOrRange: Position | Range): boolean;

		/**
		 * Check if `other` equals this range.
		 *
		 * @param other A range.
		 * @returns `true` when start and end are {@link Position.isEqual equal} to
		 * start and end of this range.
		 */
		isEqual(other: Range): boolean;

		/**
		 * Intersect `range` with this range and returns a new range or `undefined`
		 * if the ranges have no overlap.
		 *
		 * @param range A range.
		 * @returns A range of the greater start and smaller end positions. Will
		 * return undefined when there is no overlap.
		 */
		intersection(range: Range): Range | undefined;

		/**
		 * Compute the union of `other` with this range.
		 *
		 * @param other A range.
		 * @returns A range of smaller start position and the greater end position.
		 */
		union(other: Range): Range;

		/**
		 * Derived a new range from this range.
		 *
		 * @param start A position that should be used as start. The default value is the {@link Range.start current start}.
		 * @param end A position that should be used as end. The default value is the {@link Range.end current end}.
		 * @returns A range derived from this range with the given start and end position.
		 * If start and end are not different `this` range will be returned.
		 */
		with(start?: Position, end?: Position): Range;

		/**
		 * Derived a new range from this range.
		 *
		 * @param change An object that describes a change to this range.
		 * @returns A range that reflects the given change. Will return `this` range if the change
		 * is not changing anything.
		 */
		with(change: {
			/**
			 * New start position, defaults to {@link Range.start current start}
			 */
			start?: Position;
			/**
			 * New end position, defaults to {@link Range.end current end}
			 */
			end?: Position;
		}): Range;
	}

	/**
	 * Represents a text selection in an editor.
	 */
	export class Selection extends Range {

		/**
		 * The position at which the selection starts.
		 * This position might be before or after {@link Selection.active active}.
		 */
		readonly anchor: Position;

		/**
		 * The position of the cursor.
		 * This position might be before or after {@link Selection.anchor anchor}.
		 */
		readonly active: Position;

		/**
		 * Create a selection from two positions.
		 *
		 * @param anchor A position.
		 * @param active A position.
		 */
		constructor(anchor: Position, active: Position);

		/**
		 * Create a selection from four coordinates.
		 *
		 * @param anchorLine A zero-based line value.
		 * @param anchorCharacter A zero-based character value.
		 * @param activeLine A zero-based line value.
		 * @param activeCharacter A zero-based character value.
		 */
		constructor(anchorLine: number, anchorCharacter: number, activeLine: number, activeCharacter: number);

		/**
		 * A selection is reversed if its {@link Selection.anchor anchor} is the {@link Selection.end end} position.
		 */
		readonly isReversed: boolean;
	}

	/**
	 * Represents sources that can cause {@link window.onDidChangeTextEditorSelection selection change events}.
	 */
	export enum TextEditorSelectionChangeKind {
		/**
		 * Selection changed due to typing in the editor.
		 */
		Keyboard = 1,
		/**
		 * Selection change due to clicking in the editor.
		 */
		Mouse = 2,
		/**
		 * Selection changed because a command ran.
		 */
		Command = 3
	}

	/**
	 * Represents an event describing the change in a {@link TextEditor.selections text editor's selections}.
	 */
	export interface TextEditorSelectionChangeEvent {
		/**
		 * The {@link TextEditor text editor} for which the selections have changed.
		 */
		readonly textEditor: TextEditor;
		/**
		 * The new value for the {@link TextEditor.selections text editor's selections}.
		 */
		readonly selections: readonly Selection[];
		/**
		 * The {@link TextEditorSelectionChangeKind change kind} which has triggered this
		 * event. Can be `undefined`.
		 */
		readonly kind: TextEditorSelectionChangeKind | undefined;
	}

	/**
	 * Represents an event describing the change in a {@link TextEditor.visibleRanges text editor's visible ranges}.
	 */
	export interface TextEditorVisibleRangesChangeEvent {
		/**
		 * The {@link TextEditor text editor} for which the visible ranges have changed.
		 */
		readonly textEditor: TextEditor;
		/**
		 * The new value for the {@link TextEditor.visibleRanges text editor's visible ranges}.
		 */
		readonly visibleRanges: readonly Range[];
	}

	/**
	 * Represents an event describing the change in a {@link TextEditor.options text editor's options}.
	 */
	export interface TextEditorOptionsChangeEvent {
		/**
		 * The {@link TextEditor text editor} for which the options have changed.
		 */
		readonly textEditor: TextEditor;
		/**
		 * The new value for the {@link TextEditor.options text editor's options}.
		 */
		readonly options: TextEditorOptions;
	}

	/**
	 * Represents an event describing the change of a {@link TextEditor.viewColumn text editor's view column}.
	 */
	export interface TextEditorViewColumnChangeEvent {
		/**
		 * The {@link TextEditor text editor} for which the view column has changed.
		 */
		readonly textEditor: TextEditor;
		/**
		 * The new value for the {@link TextEditor.viewColumn text editor's view column}.
		 */
		readonly viewColumn: ViewColumn;
	}

	/**
	 * Rendering style of the cursor.
	 */
	export enum TextEditorCursorStyle {
		/**
		 * Render the cursor as a vertical thick line.
		 */
		Line = 1,
		/**
		 * Render the cursor as a block filled.
		 */
		Block = 2,
		/**
		 * Render the cursor as a thick horizontal line.
		 */
		Underline = 3,
		/**
		 * Render the cursor as a vertical thin line.
		 */
		LineThin = 4,
		/**
		 * Render the cursor as a block outlined.
		 */
		BlockOutline = 5,
		/**
		 * Render the cursor as a thin horizontal line.
		 */
		UnderlineThin = 6
	}

	/**
	 * Rendering style of the line numbers.
	 */
	export enum TextEditorLineNumbersStyle {
		/**
		 * Do not render the line numbers.
		 */
		Off = 0,
		/**
		 * Render the line numbers.
		 */
		On = 1,
		/**
		 * Render the line numbers with values relative to the primary cursor location.
		 */
		Relative = 2,
		/**
		 * Render the line numbers on every 10th line number.
		 */
		Interval = 3,
	}

	/**
	 * Represents a {@link TextEditor text editor}'s {@link TextEditor.options options}.
	 */
	export interface TextEditorOptions {

		/**
		 * The size in spaces a tab takes. This is used for two purposes:
		 *  - the rendering width of a tab character;
		 *  - the number of spaces to insert when {@link TextEditorOptions.insertSpaces insertSpaces} is true
		 *    and `indentSize` is set to `"tabSize"`.
		 *
		 * When getting a text editor's options, this property will always be a number (resolved).
		 * When setting a text editor's options, this property is optional and it can be a number or `"auto"`.
		 */
		tabSize?: number | string;

		/**
		 * The number of spaces to insert when {@link TextEditorOptions.insertSpaces insertSpaces} is true.
		 *
		 * When getting a text editor's options, this property will always be a number (resolved).
		 * When setting a text editor's options, this property is optional and it can be a number or `"tabSize"`.
		 */
		indentSize?: number | string;

		/**
		 * When pressing Tab insert {@link TextEditorOptions.tabSize n} spaces.
		 * When getting a text editor's options, this property will always be a boolean (resolved).
		 * When setting a text editor's options, this property is optional and it can be a boolean or `"auto"`.
		 */
		insertSpaces?: boolean | string;

		/**
		 * The rendering style of the cursor in this editor.
		 * When getting a text editor's options, this property will always be present.
		 * When setting a text editor's options, this property is optional.
		 */
		cursorStyle?: TextEditorCursorStyle;

		/**
		 * Render relative line numbers w.r.t. the current line number.
		 * When getting a text editor's options, this property will always be present.
		 * When setting a text editor's options, this property is optional.
		 */
		lineNumbers?: TextEditorLineNumbersStyle;
	}

	/**
	 * Represents a handle to a set of decorations
	 * sharing the same {@link DecorationRenderOptions styling options} in a {@link TextEditor text editor}.
	 *
	 * To get an instance of a `TextEditorDecorationType` use
	 * {@link window.createTextEditorDecorationType createTextEditorDecorationType}.
	 */
	export interface TextEditorDecorationType {

		/**
		 * Internal representation of the handle.
		 */
		readonly key: string;

		/**
		 * Remove this decoration type and all decorations on all text editors using it.
		 */
		dispose(): void;
	}

	/**
	 * Represents different {@link TextEditor.revealRange reveal} strategies in a text editor.
	 */
	export enum TextEditorRevealType {
		/**
		 * The range will be revealed with as little scrolling as possible.
		 */
		Default = 0,
		/**
		 * The range will always be revealed in the center of the viewport.
		 */
		InCenter = 1,
		/**
		 * If the range is outside the viewport, it will be revealed in the center of the viewport.
		 * Otherwise, it will be revealed with as little scrolling as possible.
		 */
		InCenterIfOutsideViewport = 2,
		/**
		 * The range will always be revealed at the top of the viewport.
		 */
		AtTop = 3
	}

	/**
	 * Represents different positions for rendering a decoration in an {@link DecorationRenderOptions.overviewRulerLane overview ruler}.
	 * The overview ruler supports three lanes.
	 */
	export enum OverviewRulerLane {
		/**
		 * The left lane of the overview ruler.
		 */
		Left = 1,
		/**
		 * The center lane of the overview ruler.
		 */
		Center = 2,
		/**
		 * The right lane of the overview ruler.
		 */
		Right = 4,
		/**
		 * All lanes of the overview ruler.
		 */
		Full = 7
	}

	/**
	 * Describes the behavior of decorations when typing/editing at their edges.
	 */
	export enum DecorationRangeBehavior {
		/**
		 * The decoration's range will widen when edits occur at the start or end.
		 */
		OpenOpen = 0,
		/**
		 * The decoration's range will not widen when edits occur at the start or end.
		 */
		ClosedClosed = 1,
		/**
		 * The decoration's range will widen when edits occur at the start, but not at the end.
		 */
		OpenClosed = 2,
		/**
		 * The decoration's range will widen when edits occur at the end, but not at the start.
		 */
		ClosedOpen = 3
	}

	/**
	 * Represents options to configure the behavior of showing a {@link TextDocument document} in an {@link TextEditor editor}.
	 */
	export interface TextDocumentShowOptions {
		/**
		 * An optional view column in which the {@link TextEditor editor} should be shown.
		 * The default is the {@link ViewColumn.Active active}. Columns that do not exist
		 * will be created as needed up to the maximum of {@linkcode ViewColumn.Nine}.
		 * Use {@linkcode ViewColumn.Beside} to open the editor to the side of the currently
		 * active one.
		 */
		viewColumn?: ViewColumn;

		/**
		 * An optional flag that when `true` will stop the {@link TextEditor editor} from taking focus.
		 */
		preserveFocus?: boolean;

		/**
		 * An optional flag that controls if an {@link TextEditor editor}-tab shows as preview. Preview tabs will
		 * be replaced and reused until set to stay - either explicitly or through editing.
		 *
		 * *Note* that the flag is ignored if a user has disabled preview editors in settings.
		 */
		preview?: boolean;

		/**
		 * An optional selection to apply for the document in the {@link TextEditor editor}.
		 */
		selection?: Range;
	}

	/**
	 * Represents an event describing the change in a {@link NotebookEditor.selections notebook editor's selections}.
	 */
	export interface NotebookEditorSelectionChangeEvent {
		/**
		 * The {@link NotebookEditor notebook editor} for which the selections have changed.
		 */
		readonly notebookEditor: NotebookEditor;

		/**
		 * The new value for the {@link NotebookEditor.selections notebook editor's selections}.
		 */
		readonly selections: readonly NotebookRange[];
	}

	/**
	 * Represents an event describing the change in a {@link NotebookEditor.visibleRanges notebook editor's visibleRanges}.
	 */
	export interface NotebookEditorVisibleRangesChangeEvent {
		/**
		 * The {@link NotebookEditor notebook editor} for which the visible ranges have changed.
		 */
		readonly notebookEditor: NotebookEditor;

		/**
		 * The new value for the {@link NotebookEditor.visibleRanges notebook editor's visibleRanges}.
		 */
		readonly visibleRanges: readonly NotebookRange[];
	}

	/**
	 * Represents options to configure the behavior of showing a {@link NotebookDocument notebook document} in an {@link NotebookEditor notebook editor}.
	 */
	export interface NotebookDocumentShowOptions {
		/**
		 * An optional view column in which the {@link NotebookEditor notebook editor} should be shown.
		 * The default is the {@link ViewColumn.Active active}. Columns that do not exist
		 * will be created as needed up to the maximum of {@linkcode ViewColumn.Nine}.
		 * Use {@linkcode ViewColumn.Beside} to open the editor to the side of the currently
		 * active one.
		 */
		readonly viewColumn?: ViewColumn;

		/**
		 * An optional flag that when `true` will stop the {@link NotebookEditor notebook editor} from taking focus.
		 */
		readonly preserveFocus?: boolean;

		/**
		 * An optional flag that controls if an {@link NotebookEditor notebook editor}-tab shows as preview. Preview tabs will
		 * be replaced and reused until set to stay - either explicitly or through editing. The default behaviour depends
		 * on the `workbench.editor.enablePreview`-setting.
		 */
		readonly preview?: boolean;

		/**
		 * An optional selection to apply for the document in the {@link NotebookEditor notebook editor}.
		 */
		readonly selections?: readonly NotebookRange[];
	}

	/**
	 * A reference to one of the workbench colors as defined in https://code.visualstudio.com/api/references/theme-color.
	 * Using a theme color is preferred over a custom color as it gives theme authors and users the possibility to change the color.
	 */
	export class ThemeColor {

		/**
		 * The id of this color.
		 */
		readonly id: string;

		/**
		 * Creates a reference to a theme color.
		 * @param id of the color. The available colors are listed in https://code.visualstudio.com/api/references/theme-color.
		 */
		constructor(id: string);
	}

	/**
	 * A reference to a named icon. Currently, {@link ThemeIcon.File File}, {@link ThemeIcon.Folder Folder},
	 * and [ThemeIcon ids](https://code.visualstudio.com/api/references/icons-in-labels#icon-listing) are supported.
	 * Using a theme icon is preferred over a custom icon as it gives product theme authors the possibility to change the icons.
	 *
	 * *Note* that theme icons can also be rendered inside labels and descriptions. Places that support theme icons spell this out
	 * and they use the `$(<name>)`-syntax, for instance `quickPick.label = "Hello World $(globe)"`.
	 */
	export class ThemeIcon {
		/**
		 * Reference to an icon representing a file. The icon is taken from the current file icon theme or a placeholder icon is used.
		 */
		static readonly File: ThemeIcon;

		/**
		 * Reference to an icon representing a folder. The icon is taken from the current file icon theme or a placeholder icon is used.
		 */
		static readonly Folder: ThemeIcon;

		/**
		 * The id of the icon. The available icons are listed in https://code.visualstudio.com/api/references/icons-in-labels#icon-listing.
		 */
		readonly id: string;

		/**
		 * The optional ThemeColor of the icon. The color is currently only used in {@link TreeItem}.
		 */
		readonly color?: ThemeColor | undefined;

		/**
		 * Creates a reference to a theme icon.
		 * @param id id of the icon. The available icons are listed in https://code.visualstudio.com/api/references/icons-in-labels#icon-listing.
		 * @param color optional `ThemeColor` for the icon. The color is currently only used in {@link TreeItem}.
		 */
		constructor(id: string, color?: ThemeColor);
	}

	/**
	 * Represents an icon in the UI. This is either an uri, separate uris for the light- and dark-themes,
	 * or a {@link ThemeIcon theme icon}.
	 */
	export type IconPath = Uri | {
		/**
		 * The icon path for the light theme.
		 */
		light: Uri;
		/**
		 * The icon path for the dark theme.
		 */
		dark: Uri;
	} | ThemeIcon;

	/**
	 * Represents theme specific rendering styles for a {@link TextEditorDecorationType text editor decoration}.
	 */
	export interface ThemableDecorationRenderOptions {
		/**
		 * Background color of the decoration. Use rgba() and define transparent background colors to play well with other decorations.
		 * Alternatively a color from the color registry can be {@link ThemeColor referenced}.
		 */
		backgroundColor?: string | ThemeColor;

		/**
		 * CSS styling property that will be applied to text enclosed by a decoration.
		 */
		outline?: string;

		/**
		 * CSS styling property that will be applied to text enclosed by a decoration.
		 * Better use 'outline' for setting one or more of the individual outline properties.
		 */
		outlineColor?: string | ThemeColor;

		/**
		 * CSS styling property that will be applied to text enclosed by a decoration.
		 * Better use 'outline' for setting one or more of the individual outline properties.
		 */
		outlineStyle?: string;

		/**
		 * CSS styling property that will be applied to text enclosed by a decoration.
		 * Better use 'outline' for setting one or more of the individual outline properties.
		 */
		outlineWidth?: string;

		/**
		 * CSS styling property that will be applied to text enclosed by a decoration.
		 */
		border?: string;

		/**
		 * CSS styling property that will be applied to text enclosed by a decoration.
		 * Better use 'border' for setting one or more of the individual border properties.
		 */
		borderColor?: string | ThemeColor;

		/**
		 * CSS styling property that will be applied to text enclosed by a decoration.
		 * Better use 'border' for setting one or more of the individual border properties.
		 */
		borderRadius?: string;

		/**
		 * CSS styling property that will be applied to text enclosed by a decoration.
		 * Better use 'border' for setting one or more of the individual border properties.
		 */
		borderSpacing?: string;

		/**
		 * CSS styling property that will be applied to text enclosed by a decoration.
		 * Better use 'border' for setting one or more of the individual border properties.
		 */
		borderStyle?: string;

		/**
		 * CSS styling property that will be applied to text enclosed by a decoration.
		 * Better use 'border' for setting one or more of the individual border properties.
		 */
		borderWidth?: string;

		/**
		 * CSS styling property that will be applied to text enclosed by a decoration.
		 */
		fontStyle?: string;

		/**
		 * CSS styling property that will be applied to text enclosed by a decoration.
		 */
		fontWeight?: string;

		/**
		 * CSS styling property that will be applied to text enclosed by a decoration.
		 */
		textDecoration?: string;

		/**
		 * CSS styling property that will be applied to text enclosed by a decoration.
		 */
		cursor?: string;

		/**
		 * CSS styling property that will be applied to text enclosed by a decoration.
		 */
		color?: string | ThemeColor;

		/**
		 * CSS styling property that will be applied to text enclosed by a decoration.
		 */
		opacity?: string;

		/**
		 * CSS styling property that will be applied to text enclosed by a decoration.
		 */
		letterSpacing?: string;

		/**
		 * An **absolute path** or an URI to an image to be rendered in the gutter.
		 */
		gutterIconPath?: string | Uri;

		/**
		 * Specifies the size of the gutter icon.
		 * Available values are 'auto', 'contain', 'cover' and any percentage value.
		 * For further information: https://msdn.microsoft.com/en-us/library/jj127316(v=vs.85).aspx
		 */
		gutterIconSize?: string;

		/**
		 * The color of the decoration in the overview ruler. Use rgba() and define transparent colors to play well with other decorations.
		 */
		overviewRulerColor?: string | ThemeColor;

		/**
		 * Defines the rendering options of the attachment that is inserted before the decorated text.
		 */
		before?: ThemableDecorationAttachmentRenderOptions;

		/**
		 * Defines the rendering options of the attachment that is inserted after the decorated text.
		 */
		after?: ThemableDecorationAttachmentRenderOptions;
	}

	/**
	 * Represents theme specific rendering styles for {@link ThemableDecorationRenderOptions.before before} and
	 * {@link ThemableDecorationRenderOptions.after after} the content of text decorations.
	 */
	export interface ThemableDecorationAttachmentRenderOptions {
		/**
		 * Defines a text content that is shown in the attachment. Either an icon or a text can be shown, but not both.
		 */
		contentText?: string;
		/**
		 * An **absolute path** or an URI to an image to be rendered in the attachment. Either an icon
		 * or a text can be shown, but not both.
		 */
		contentIconPath?: string | Uri;
		/**
		 * CSS styling property that will be applied to the decoration attachment.
		 */
		border?: string;
		/**
		 * CSS styling property that will be applied to text enclosed by a decoration.
		 */
		borderColor?: string | ThemeColor;
		/**
		 * CSS styling property that will be applied to the decoration attachment.
		 */
		fontStyle?: string;
		/**
		 * CSS styling property that will be applied to the decoration attachment.
		 */
		fontWeight?: string;
		/**
		 * CSS styling property that will be applied to the decoration attachment.
		 */
		textDecoration?: string;
		/**
		 * CSS styling property that will be applied to the decoration attachment.
		 */
		color?: string | ThemeColor;
		/**
		 * CSS styling property that will be applied to the decoration attachment.
		 */
		backgroundColor?: string | ThemeColor;
		/**
		 * CSS styling property that will be applied to the decoration attachment.
		 */
		margin?: string;
		/**
		 * CSS styling property that will be applied to the decoration attachment.
		 */
		width?: string;
		/**
		 * CSS styling property that will be applied to the decoration attachment.
		 */
		height?: string;
	}

	/**
	 * Represents rendering styles for a {@link TextEditorDecorationType text editor decoration}.
	 */
	export interface DecorationRenderOptions extends ThemableDecorationRenderOptions {
		/**
		 * Should the decoration be rendered also on the whitespace after the line text.
		 * Defaults to `false`.
		 */
		isWholeLine?: boolean;

		/**
		 * Customize the growing behavior of the decoration when edits occur at the edges of the decoration's range.
		 * Defaults to `DecorationRangeBehavior.OpenOpen`.
		 */
		rangeBehavior?: DecorationRangeBehavior;

		/**
		 * The position in the overview ruler where the decoration should be rendered.
		 */
		overviewRulerLane?: OverviewRulerLane;

		/**
		 * Overwrite options for light themes.
		 */
		light?: ThemableDecorationRenderOptions;

		/**
		 * Overwrite options for dark themes.
		 */
		dark?: ThemableDecorationRenderOptions;
	}

	/**
	 * Represents options for a specific decoration in a {@link TextEditorDecorationType decoration set}.
	 */
	export interface DecorationOptions {

		/**
		 * Range to which this decoration is applied. The range must not be empty.
		 */
		range: Range;

		/**
		 * A message that should be rendered when hovering over the decoration.
		 */
		hoverMessage?: MarkdownString | MarkedString | Array<MarkdownString | MarkedString>;

		/**
		 * Render options applied to the current decoration. For performance reasons, keep the
		 * number of decoration specific options small, and use decoration types wherever possible.
		 */
		renderOptions?: DecorationInstanceRenderOptions;
	}

	/**
	 * Represents themable render options for decoration instances.
	 */
	export interface ThemableDecorationInstanceRenderOptions {
		/**
		 * Defines the rendering options of the attachment that is inserted before the decorated text.
		 */
		before?: ThemableDecorationAttachmentRenderOptions;

		/**
		 * Defines the rendering options of the attachment that is inserted after the decorated text.
		 */
		after?: ThemableDecorationAttachmentRenderOptions;
	}

	/**
	 * Represents render options for decoration instances. See {@link DecorationOptions.renderOptions}.
	 */
	export interface DecorationInstanceRenderOptions extends ThemableDecorationInstanceRenderOptions {
		/**
		 * Overwrite options for light themes.
		 */
		light?: ThemableDecorationInstanceRenderOptions;

		/**
		 * Overwrite options for dark themes.
		 */
		dark?: ThemableDecorationInstanceRenderOptions;
	}

	/**
	 * Represents an editor that is attached to a {@link TextDocument document}.
	 */
	export interface TextEditor {

		/**
		 * The document associated with this text editor. The document will be the same for the entire lifetime of this text editor.
		 */
		readonly document: TextDocument;

		/**
		 * The primary selection on this text editor. Shorthand for `TextEditor.selections[0]`.
		 */
		selection: Selection;

		/**
		 * The selections in this text editor. The primary selection is always at index 0.
		 */
		selections: readonly Selection[];

		/**
		 * The current visible ranges in the editor (vertically).
		 * This accounts only for vertical scrolling, and not for horizontal scrolling.
		 */
		readonly visibleRanges: readonly Range[];

		/**
		 * Text editor options.
		 */
		options: TextEditorOptions;

		/**
		 * The column in which this editor shows. Will be `undefined` in case this
		 * isn't one of the main editors, e.g. an embedded editor, or when the editor
		 * column is larger than three.
		 */
		readonly viewColumn: ViewColumn | undefined;

		/**
		 * Perform an edit on the document associated with this text editor.
		 *
		 * The given callback-function is invoked with an {@link TextEditorEdit edit-builder} which must
		 * be used to make edits. Note that the edit-builder is only valid while the
		 * callback executes.
		 *
		 * @param callback A function which can create edits using an {@link TextEditorEdit edit-builder}.
		 * @param options The undo/redo behavior around this edit. By default, undo stops will be created before and after this edit.
		 * @returns A promise that resolves with a value indicating if the edits could be applied.
		 */
		edit(callback: (editBuilder: TextEditorEdit) => void, options?: {
			/**
			 * Add undo stop before making the edits.
			 */
			readonly undoStopBefore: boolean;
			/**
			 * Add undo stop after making the edits.
			 */
			readonly undoStopAfter: boolean;
		}): Thenable<boolean>;

		/**
		 * Insert a {@link SnippetString snippet} and put the editor into snippet mode. "Snippet mode"
		 * means the editor adds placeholders and additional cursors so that the user can complete
		 * or accept the snippet.
		 *
		 * @param snippet The snippet to insert in this edit.
		 * @param location Position or range at which to insert the snippet, defaults to the current editor selection or selections.
		 * @param options The undo/redo behavior around this edit. By default, undo stops will be created before and after this edit.
		 * @returns A promise that resolves with a value indicating if the snippet could be inserted. Note that the promise does not signal
		 * that the snippet is completely filled-in or accepted.
		 */
		insertSnippet(snippet: SnippetString, location?: Position | Range | readonly Position[] | readonly Range[], options?: {
			/**
			 * Add undo stop before making the edits.
			 */
			readonly undoStopBefore: boolean;
			/**
			 * Add undo stop after making the edits.
			 */
			readonly undoStopAfter: boolean;
			/**
			 * Keep whitespace of the {@link SnippetString.value} as is.
			 */
			readonly keepWhitespace?: boolean;
		}): Thenable<boolean>;

		/**
		 * Adds a set of decorations to the text editor. If a set of decorations already exists with
		 * the given {@link TextEditorDecorationType decoration type}, they will be replaced. If
		 * `rangesOrOptions` is empty, the existing decorations with the given {@link TextEditorDecorationType decoration type}
		 * will be removed.
		 *
		 * @see {@link window.createTextEditorDecorationType createTextEditorDecorationType}.
		 *
		 * @param decorationType A decoration type.
		 * @param rangesOrOptions Either {@link Range ranges} or more detailed {@link DecorationOptions options}.
		 */
		setDecorations(decorationType: TextEditorDecorationType, rangesOrOptions: readonly Range[] | readonly DecorationOptions[]): void;

		/**
		 * Scroll as indicated by `revealType` in order to reveal the given range.
		 *
		 * @param range A range.
		 * @param revealType The scrolling strategy for revealing `range`.
		 */
		revealRange(range: Range, revealType?: TextEditorRevealType): void;

		/**
		 * Show the text editor.
		 *
		 * @deprecated Use {@link window.showTextDocument} instead.
		 *
		 * @param column The {@link ViewColumn column} in which to show this editor.
		 * This method shows unexpected behavior and will be removed in the next major update.
		 */
		show(column?: ViewColumn): void;

		/**
		 * Hide the text editor.
		 *
		 * @deprecated Use the command `workbench.action.closeActiveEditor` instead.
		 * This method shows unexpected behavior and will be removed in the next major update.
		 */
		hide(): void;
	}

	/**
	 * Represents an end of line character sequence in a {@link TextDocument document}.
	 */
	export enum EndOfLine {
		/**
		 * The line feed `\n` character.
		 */
		LF = 1,
		/**
		 * The carriage return line feed `\r\n` sequence.
		 */
		CRLF = 2
	}

	/**
	 * A complex edit that will be applied in one transaction on a TextEditor.
	 * This holds a description of the edits and if the edits are valid (i.e. no overlapping regions, document was not changed in the meantime, etc.)
	 * they can be applied on a {@link TextDocument document} associated with a {@link TextEditor text editor}.
	 */
	export interface TextEditorEdit {
		/**
		 * Replace a certain text region with a new value.
		 * You can use `\r\n` or `\n` in `value` and they will be normalized to the current {@link TextDocument document}.
		 *
		 * @param location The range this operation should remove.
		 * @param value The new text this operation should insert after removing `location`.
		 */
		replace(location: Position | Range | Selection, value: string): void;

		/**
		 * Insert text at a location.
		 * You can use `\r\n` or `\n` in `value` and they will be normalized to the current {@link TextDocument document}.
		 * Although the equivalent text edit can be made with {@link TextEditorEdit.replace replace}, `insert` will produce a different resulting selection (it will get moved).
		 *
		 * @param location The position where the new text should be inserted.
		 * @param value The new text this operation should insert.
		 */
		insert(location: Position, value: string): void;

		/**
		 * Delete a certain text region.
		 *
		 * @param location The range this operation should remove.
		 */
		delete(location: Range | Selection): void;

		/**
		 * Set the end of line sequence.
		 *
		 * @param endOfLine The new end of line for the {@link TextDocument document}.
		 */
		setEndOfLine(endOfLine: EndOfLine): void;
	}

	/**
	 * A universal resource identifier representing either a file on disk
	 * or another resource, like untitled resources.
	 */
	export class Uri {

		/**
		 * Create an URI from a string, e.g. `http://www.example.com/some/path`,
		 * `file:///usr/home`, or `scheme:with/path`.
		 *
		 * *Note* that for a while uris without a `scheme` were accepted. That is not correct
		 * as all uris should have a scheme. To avoid breakage of existing code the optional
		 * `strict`-argument has been added. We *strongly* advise to use it, e.g. `Uri.parse('my:uri', true)`
		 *
		 * @see {@link Uri.toString}
		 * @param value The string value of an Uri.
		 * @param strict Throw an error when `value` is empty or when no `scheme` can be parsed.
		 * @returns A new Uri instance.
		 */
		static parse(value: string, strict?: boolean): Uri;

		/**
		 * Create an URI from a file system path. The {@link Uri.scheme scheme}
		 * will be `file`.
		 *
		 * The *difference* between {@link Uri.parse} and {@link Uri.file} is that the latter treats the argument
		 * as path, not as stringified-uri. E.g. `Uri.file(path)` is *not* the same as
		 * `Uri.parse('file://' + path)` because the path might contain characters that are
		 * interpreted (# and ?). See the following sample:
		 * ```ts
		 * const good = URI.file('/coding/c#/project1');
		 * good.scheme === 'file';
		 * good.path === '/coding/c#/project1';
		 * good.fragment === '';
		 *
		 * const bad = URI.parse('file://' + '/coding/c#/project1');
		 * bad.scheme === 'file';
		 * bad.path === '/coding/c'; // path is now broken
		 * bad.fragment === '/project1';
		 * ```
		 *
		 * @param path A file system or UNC path.
		 * @returns A new Uri instance.
		 */
		static file(path: string): Uri;

		/**
		 * Create a new uri which path is the result of joining
		 * the path of the base uri with the provided path segments.
		 *
		 * - Note 1: `joinPath` only affects the path component
		 * and all other components (scheme, authority, query, and fragment) are
		 * left as they are.
		 * - Note 2: The base uri must have a path; an error is thrown otherwise.
		 *
		 * The path segments are normalized in the following ways:
		 * - sequences of path separators (`/` or `\`) are replaced with a single separator
		 * - for `file`-uris on windows, the backslash-character (`\`) is considered a path-separator
		 * - the `..`-segment denotes the parent segment, the `.` denotes the current segment
		 * - paths have a root which always remains, for instance on windows drive-letters are roots
		 * so that is true: `joinPath(Uri.file('file:///c:/root'), '../../other').fsPath === 'c:/other'`
		 *
		 * @param base An uri. Must have a path.
		 * @param pathSegments One more more path fragments
		 * @returns A new uri which path is joined with the given fragments
		 */
		static joinPath(base: Uri, ...pathSegments: string[]): Uri;

		/**
		 * Create an URI from its component parts
		 *
		 * @see {@link Uri.toString}
		 * @param components The component parts of an Uri.
		 * @returns A new Uri instance.
		 */
		static from(components: {
			/**
			 * The scheme of the uri
			 */
			readonly scheme: string;
			/**
			 * The authority of the uri
			 */
			readonly authority?: string;
			/**
			 * The path of the uri
			 */
			readonly path?: string;
			/**
			 * The query string of the uri
			 */
			readonly query?: string;
			/**
			 * The fragment identifier of the uri
			 */
			readonly fragment?: string;
		}): Uri;

		/**
		 * Use the `file` and `parse` factory functions to create new `Uri` objects.
		 */
		private constructor(scheme: string, authority: string, path: string, query: string, fragment: string);

		/**
		 * Scheme is the `http` part of `http://www.example.com/some/path?query#fragment`.
		 * The part before the first colon.
		 */
		readonly scheme: string;

		/**
		 * Authority is the `www.example.com` part of `http://www.example.com/some/path?query#fragment`.
		 * The part between the first double slashes and the next slash.
		 */
		readonly authority: string;

		/**
		 * Path is the `/some/path` part of `http://www.example.com/some/path?query#fragment`.
		 */
		readonly path: string;

		/**
		 * Query is the `query` part of `http://www.example.com/some/path?query#fragment`.
		 */
		readonly query: string;

		/**
		 * Fragment is the `fragment` part of `http://www.example.com/some/path?query#fragment`.
		 */
		readonly fragment: string;

		/**
		 * The string representing the corresponding file system path of this Uri.
		 *
		 * Will handle UNC paths and normalize windows drive letters to lower-case. Also
		 * uses the platform specific path separator.
		 *
		 * * Will *not* validate the path for invalid characters and semantics.
		 * * Will *not* look at the scheme of this Uri.
		 * * The resulting string shall *not* be used for display purposes but
		 * for disk operations, like `readFile` et al.
		 *
		 * The *difference* to the {@linkcode Uri.path path}-property is the use of the platform specific
		 * path separator and the handling of UNC paths. The sample below outlines the difference:
		 * ```ts
		 * const u = URI.parse('file://server/c$/folder/file.txt')
		 * u.authority === 'server'
		 * u.path === '/c$/folder/file.txt'
		 * u.fsPath === '\\server\c$\folder\file.txt'
		 * ```
		 */
		readonly fsPath: string;

		/**
		 * Derive a new Uri from this Uri.
		 *
		 * ```ts
		 * let file = Uri.parse('before:some/file/path');
		 * let other = file.with({ scheme: 'after' });
		 * assert.ok(other.toString() === 'after:some/file/path');
		 * ```
		 *
		 * @param change An object that describes a change to this Uri. To unset components use `null` or
		 *  the empty string.
		 * @returns A new Uri that reflects the given change. Will return `this` Uri if the change
		 *  is not changing anything.
		 */
		with(change: {
			/**
			 * The new scheme, defaults to this Uri's scheme.
			 */
			scheme?: string;
			/**
			 * The new authority, defaults to this Uri's authority.
			 */
			authority?: string;
			/**
			 * The new path, defaults to this Uri's path.
			 */
			path?: string;
			/**
			 * The new query, defaults to this Uri's query.
			 */
			query?: string;
			/**
			 * The new fragment, defaults to this Uri's fragment.
			 */
			fragment?: string;
		}): Uri;

		/**
		 * Returns a string representation of this Uri. The representation and normalization
		 * of a URI depends on the scheme.
		 *
		 * * The resulting string can be safely used with {@link Uri.parse}.
		 * * The resulting string shall *not* be used for display purposes.
		 *
		 * *Note* that the implementation will encode _aggressive_ which often leads to unexpected,
		 * but not incorrect, results. For instance, colons are encoded to `%3A` which might be unexpected
		 * in file-uri. Also `&` and `=` will be encoded which might be unexpected for http-uris. For stability
		 * reasons this cannot be changed anymore. If you suffer from too aggressive encoding you should use
		 * the `skipEncoding`-argument: `uri.toString(true)`.
		 *
		 * @param skipEncoding Do not percentage-encode the result, defaults to `false`. Note that
		 *	the `#` and `?` characters occurring in the path will always be encoded.
		 * @returns A string representation of this Uri.
		 */
		toString(skipEncoding?: boolean): string;

		/**
		 * Returns a JSON representation of this Uri.
		 *
		 * @returns An object.
		 */
		toJSON(): any;
	}

	/**
	 * A cancellation token is passed to an asynchronous or long running
	 * operation to request cancellation, like cancelling a request
	 * for completion items because the user continued to type.
	 *
	 * To get an instance of a `CancellationToken` use a
	 * {@link CancellationTokenSource}.
	 */
	export interface CancellationToken {

		/**
		 * Is `true` when the token has been cancelled, `false` otherwise.
		 */
		isCancellationRequested: boolean;

		/**
		 * An {@link Event} which fires upon cancellation.
		 */
		readonly onCancellationRequested: Event<any>;
	}

	/**
	 * A cancellation source creates and controls a {@link CancellationToken cancellation token}.
	 */
	export class CancellationTokenSource {

		/**
		 * The cancellation token of this source.
		 */
		token: CancellationToken;

		/**
		 * Signal cancellation on the token.
		 */
		cancel(): void;

		/**
		 * Dispose object and free resources.
		 */
		dispose(): void;
	}

	/**
	 * An error type that should be used to signal cancellation of an operation.
	 *
	 * This type can be used in response to a {@link CancellationToken cancellation token}
	 * being cancelled or when an operation is being cancelled by the
	 * executor of that operation.
	 */
	export class CancellationError extends Error {

		/**
		 * Creates a new cancellation error.
		 */
		constructor();
	}

	/**
	 * Represents a type which can release resources, such
	 * as event listening or a timer.
	 */
	export class Disposable {

		/**
		 * Combine many disposable-likes into one. You can use this method when having objects with
		 * a dispose function which aren't instances of `Disposable`.
		 *
		 * @param disposableLikes Objects that have at least a `dispose`-function member. Note that asynchronous
		 * dispose-functions aren't awaited.
		 * @returns Returns a new disposable which, upon dispose, will
		 * dispose all provided disposables.
		 */
		static from(...disposableLikes: {
			/**
			 * Function to clean up resources.
			 */
			dispose: () => any;
		}[]): Disposable;

		/**
		 * Creates a new disposable that calls the provided function
		 * on dispose.
		 *
		 * *Note* that an asynchronous function is not awaited.
		 *
		 * @param callOnDispose Function that disposes something.
		 */
		constructor(callOnDispose: () => any);

		/**
		 * Dispose this object.
		 */
		dispose(): any;
	}

	/**
	 * Represents a typed event.
	 *
	 * A function that represents an event to which you subscribe by calling it with
	 * a listener function as argument.
	 *
	 * @example
	 * item.onDidChange(function(event) { console.log("Event happened: " + event); });
	 */
	export interface Event<T> {

		/**
		 * A function that represents an event to which you subscribe by calling it with
		 * a listener function as argument.
		 *
		 * @param listener The listener function will be called when the event happens.
		 * @param thisArgs The `this`-argument which will be used when calling the event listener.
		 * @param disposables An array to which a {@link Disposable} will be added.
		 * @returns A disposable which unsubscribes the event listener.
		 */
		(listener: (e: T) => any, thisArgs?: any, disposables?: Disposable[]): Disposable;
	}

	/**
	 * An event emitter can be used to create and manage an {@link Event} for others
	 * to subscribe to. One emitter always owns one event.
	 *
	 * Use this class if you want to provide event from within your extension, for instance
	 * inside a {@link TextDocumentContentProvider} or when providing
	 * API to other extensions.
	 */
	export class EventEmitter<T> {

		/**
		 * The event listeners can subscribe to.
		 */
		event: Event<T>;

		/**
		 * Notify all subscribers of the {@link EventEmitter.event event}. Failure
		 * of one or more listener will not fail this function call.
		 *
		 * @param data The event object.
		 */
		fire(data: T): void;

		/**
		 * Dispose this object and free resources.
		 */
		dispose(): void;
	}

	/**
	 * A file system watcher notifies about changes to files and folders
	 * on disk or from other {@link FileSystemProvider FileSystemProviders}.
	 *
	 * To get an instance of a `FileSystemWatcher` use
	 * {@link workspace.createFileSystemWatcher createFileSystemWatcher}.
	 */
	export interface FileSystemWatcher extends Disposable {

		/**
		 * true if this file system watcher has been created such that
		 * it ignores creation file system events.
		 */
		readonly ignoreCreateEvents: boolean;

		/**
		 * true if this file system watcher has been created such that
		 * it ignores change file system events.
		 */
		readonly ignoreChangeEvents: boolean;

		/**
		 * true if this file system watcher has been created such that
		 * it ignores delete file system events.
		 */
		readonly ignoreDeleteEvents: boolean;

		/**
		 * An event which fires on file/folder creation.
		 */
		readonly onDidCreate: Event<Uri>;

		/**
		 * An event which fires on file/folder change.
		 */
		readonly onDidChange: Event<Uri>;

		/**
		 * An event which fires on file/folder deletion.
		 */
		readonly onDidDelete: Event<Uri>;
	}

	/**
	 * A text document content provider allows to add readonly documents
	 * to the editor, such as source from a dll or generated html from md.
	 *
	 * Content providers are {@link workspace.registerTextDocumentContentProvider registered}
	 * for a {@link Uri.scheme uri-scheme}. When a uri with that scheme is to
	 * be {@link workspace.openTextDocument loaded} the content provider is
	 * asked.
	 */
	export interface TextDocumentContentProvider {

		/**
		 * An event to signal a resource has changed.
		 */
		onDidChange?: Event<Uri>;

		/**
		 * Provide textual content for a given uri.
		 *
		 * The editor will use the returned string-content to create a readonly
		 * {@link TextDocument document}. Resources allocated should be released when
		 * the corresponding document has been {@link workspace.onDidCloseTextDocument closed}.
		 *
		 * **Note**: The contents of the created {@link TextDocument document} might not be
		 * identical to the provided text due to end-of-line-sequence normalization.
		 *
		 * @param uri An uri which scheme matches the scheme this provider was {@link workspace.registerTextDocumentContentProvider registered} for.
		 * @param token A cancellation token.
		 * @returns A string or a thenable that resolves to such.
		 */
		provideTextDocumentContent(uri: Uri, token: CancellationToken): ProviderResult<string>;
	}

	/**
	 * The kind of {@link QuickPickItem quick pick item}.
	 */
	export enum QuickPickItemKind {
		/**
		 * When a {@link QuickPickItem} has a kind of {@link Separator}, the item is just a visual separator and does not represent a real item.
		 * The only property that applies is {@link QuickPickItem.label label }. All other properties on {@link QuickPickItem} will be ignored and have no effect.
		 */
		Separator = -1,
		/**
		 * The default {@link QuickPickItem.kind} is an item that can be selected in the quick pick.
		 */
		Default = 0,
	}

	/**
	 * Represents an item that can be selected from
	 * a list of items.
	 */
	export interface QuickPickItem {

		/**
		 * A human-readable string which is rendered prominent. Supports rendering of {@link ThemeIcon theme icons} via
		 * the `$(<name>)`-syntax.
		 *
		 * Note: When {@link QuickPickItem.kind kind} is set to {@link QuickPickItemKind.Default} (so a regular item
		 * instead of a separator), it supports rendering of {@link ThemeIcon theme icons} via the `$(<name>)`-syntax.
		 */
		label: string;

		/**
		 * The kind of QuickPickItem that will determine how this item is rendered in the quick pick. When not specified,
		 * the default is {@link QuickPickItemKind.Default}.
		 */
		kind?: QuickPickItemKind;

		/**
		 * The icon path or {@link ThemeIcon} for the QuickPickItem.
		 */
		iconPath?: IconPath;

		/**
		 * A human-readable string which is rendered less prominent in the same line. Supports rendering of
		 * {@link ThemeIcon theme icons} via the `$(<name>)`-syntax.
		 *
		 * Note: this property is ignored when {@link QuickPickItem.kind kind} is set to {@link QuickPickItemKind.Separator}
		 */
		description?: string;

		/**
		 * A human-readable string which is rendered less prominent in a separate line. Supports rendering of
		 * {@link ThemeIcon theme icons} via the `$(<name>)`-syntax.
		 *
		 * Note: this property is ignored when {@link QuickPickItem.kind kind} is set to {@link QuickPickItemKind.Separator}
		 */
		detail?: string;

		/**
		 * Optional flag indicating if this item is picked initially. This is only honored when using
		 * the {@link window.showQuickPick showQuickPick()} API. To do the same thing with
		 * the {@link window.createQuickPick createQuickPick()} API, simply set the {@link QuickPick.selectedItems}
		 * to the items you want picked initially.
		 * (*Note:* This is only honored when the picker allows multiple selections.)
		 *
		 * @see {@link QuickPickOptions.canPickMany}
		 *
		 * Note: this property is ignored when {@link QuickPickItem.kind kind} is set to {@link QuickPickItemKind.Separator}
		 */
		picked?: boolean;

		/**
		 * Always show this item.
		 *
		 * Note: this property is ignored when {@link QuickPickItem.kind kind} is set to {@link QuickPickItemKind.Separator}
		 */
		alwaysShow?: boolean;

		/**
		 * Optional buttons that will be rendered on this particular item. These buttons will trigger
		 * an {@link QuickPickItemButtonEvent} when clicked. Buttons are only rendered when using a quickpick
		 * created by the {@link window.createQuickPick createQuickPick()} API. Buttons are not rendered when using
		 * the {@link window.showQuickPick showQuickPick()} API.
		 *
		 * Note: this property is ignored when {@link QuickPickItem.kind kind} is set to {@link QuickPickItemKind.Separator}
		 */
		buttons?: readonly QuickInputButton[];
	}

	/**
	 * Options to configure the behavior of the quick pick UI.
	 */
	export interface QuickPickOptions {

		/**
		 * An optional string that represents the title of the quick pick.
		 */
		title?: string;

		/**
		 * An optional flag to include the description when filtering the picks.
		 */
		matchOnDescription?: boolean;

		/**
		 * An optional flag to include the detail when filtering the picks.
		 */
		matchOnDetail?: boolean;

		/**
		 * An optional string to show as placeholder in the input box to guide the user what to pick on.
		 */
		placeHolder?: string;

		/**
		 * Set to `true` to keep the picker open when focus moves to another part of the editor or to another window.
		 * This setting is ignored on iPad and is always false.
		 */
		ignoreFocusOut?: boolean;

		/**
		 * An optional flag to make the picker accept multiple selections, if true the result is an array of picks.
		 */
		canPickMany?: boolean;

		/**
		 * An optional function that is invoked whenever an item is selected.
		 */
		onDidSelectItem?(item: QuickPickItem | string): any;
	}

	/**
	 * Options to configure the behaviour of the {@link WorkspaceFolder workspace folder} pick UI.
	 */
	export interface WorkspaceFolderPickOptions {

		/**
		 * An optional string to show as placeholder in the input box to guide the user what to pick on.
		 */
		placeHolder?: string;

		/**
		 * Set to `true` to keep the picker open when focus moves to another part of the editor or to another window.
		 * This setting is ignored on iPad and is always false.
		 */
		ignoreFocusOut?: boolean;
	}

	/**
	 * Options to configure the behaviour of a file open dialog.
	 *
	 * * Note 1: On Windows and Linux, a file dialog cannot be both a file selector and a folder selector, so if you
	 * set both `canSelectFiles` and `canSelectFolders` to `true` on these platforms, a folder selector will be shown.
	 * * Note 2: Explicitly setting `canSelectFiles` and `canSelectFolders` to `false` is futile
	 * and the editor then silently adjusts the options to select files.
	 */
	export interface OpenDialogOptions {
		/**
		 * The resource the dialog shows when opened.
		 */
		defaultUri?: Uri;

		/**
		 * A human-readable string for the open button.
		 */
		openLabel?: string;

		/**
		 * Allow to select files, defaults to `true`.
		 */
		canSelectFiles?: boolean;

		/**
		 * Allow to select folders, defaults to `false`.
		 */
		canSelectFolders?: boolean;

		/**
		 * Allow to select many files or folders.
		 */
		canSelectMany?: boolean;

		/**
		 * A set of file filters that are used by the dialog. Each entry is a human-readable label,
		 * like "TypeScript", and an array of extensions, for example:
		 * ```ts
		 * {
		 * 	'Images': ['png', 'jpg'],
		 * 	'TypeScript': ['ts', 'tsx']
		 * }
		 * ```
		 */
		filters?: { [name: string]: string[] };

		/**
		 * Dialog title.
		 *
		 * This parameter might be ignored, as not all operating systems display a title on open dialogs
		 * (for example, macOS).
		 */
		title?: string;
	}

	/**
	 * Options to configure the behaviour of a file save dialog.
	 */
	export interface SaveDialogOptions {
		/**
		 * The resource the dialog shows when opened.
		 */
		defaultUri?: Uri;

		/**
		 * A human-readable string for the save button.
		 */
		saveLabel?: string;

		/**
		 * A set of file filters that are used by the dialog. Each entry is a human-readable label,
		 * like "TypeScript", and an array of extensions, for example:
		 * ```ts
		 * {
		 * 	'Images': ['png', 'jpg'],
		 * 	'TypeScript': ['ts', 'tsx']
		 * }
		 * ```
		 */
		filters?: { [name: string]: string[] };

		/**
		 * Dialog title.
		 *
		 * This parameter might be ignored, as not all operating systems display a title on save dialogs
		 * (for example, macOS).
		 */
		title?: string;
	}

	/**
	 * Represents an action that is shown with an information, warning, or
	 * error message.
	 *
	 * @see {@link window.showInformationMessage showInformationMessage}
	 * @see {@link window.showWarningMessage showWarningMessage}
	 * @see {@link window.showErrorMessage showErrorMessage}
	 */
	export interface MessageItem {

		/**
		 * A short title like 'Retry', 'Open Log' etc.
		 */
		title: string;

		/**
		 * A hint for modal dialogs that the item should be triggered
		 * when the user cancels the dialog (e.g. by pressing the ESC
		 * key).
		 *
		 * Note: this option is ignored for non-modal messages.
		 */
		isCloseAffordance?: boolean;
	}

	/**
	 * Options to configure the behavior of the message.
	 *
	 * @see {@link window.showInformationMessage showInformationMessage}
	 * @see {@link window.showWarningMessage showWarningMessage}
	 * @see {@link window.showErrorMessage showErrorMessage}
	 */
	export interface MessageOptions {

		/**
		 * Indicates that this message should be modal.
		 */
		modal?: boolean;

		/**
		 * Human-readable detail message that is rendered less prominent. _Note_ that detail
		 * is only shown for {@link MessageOptions.modal modal} messages.
		 */
		detail?: string;
	}

	/**
	 * Impacts the behavior and appearance of the validation message.
	 */
	/**
	 * The severity level for input box validation.
	 */
	export enum InputBoxValidationSeverity {
		/**
		 * Informational severity level.
		 */
		Info = 1,
		/**
		 * Warning severity level.
		 */
		Warning = 2,
		/**
		 * Error severity level.
		 */
		Error = 3
	}

	/**
	 * Object to configure the behavior of the validation message.
	 */
	export interface InputBoxValidationMessage {
		/**
		 * The validation message to display.
		 */
		readonly message: string;

		/**
		 * The severity of the validation message.
		 * NOTE: When using `InputBoxValidationSeverity.Error`, the user will not be allowed to accept (hit ENTER) the input.
		 * `Info` and `Warning` will still allow the InputBox to accept the input.
		 */
		readonly severity: InputBoxValidationSeverity;
	}

	/**
	 * Options to configure the behavior of the input box UI.
	 */
	export interface InputBoxOptions {

		/**
		 * An optional string that represents the title of the input box.
		 */
		title?: string;

		/**
		 * The value to pre-fill in the input box.
		 */
		value?: string;

		/**
		 * Selection of the pre-filled {@linkcode InputBoxOptions.value value}. Defined as tuple of two number where the
		 * first is the inclusive start index and the second the exclusive end index. When `undefined` the whole
		 * pre-filled value will be selected, when empty (start equals end) only the cursor will be set,
		 * otherwise the defined range will be selected.
		 */
		valueSelection?: [number, number];

		/**
		 * The text to display underneath the input box.
		 */
		prompt?: string;

		/**
		 * An optional string to show as placeholder in the input box to guide the user what to type.
		 */
		placeHolder?: string;

		/**
		 * Controls if a password input is shown. Password input hides the typed text.
		 */
		password?: boolean;

		/**
		 * Set to `true` to keep the input box open when focus moves to another part of the editor or to another window.
		 * This setting is ignored on iPad and is always false.
		 */
		ignoreFocusOut?: boolean;

		/**
		 * An optional function that will be called to validate input and to give a hint
		 * to the user.
		 *
		 * @param value The current value of the input box.
		 * @returns Either a human-readable string which is presented as an error message or an {@link InputBoxValidationMessage}
		 *  which can provide a specific message severity. Return `undefined`, `null`, or the empty string when 'value' is valid.
		 */
		validateInput?(value: string): string | InputBoxValidationMessage | undefined | null |
			Thenable<string | InputBoxValidationMessage | undefined | null>;
	}

	/**
	 * A relative pattern is a helper to construct glob patterns that are matched
	 * relatively to a base file path. The base path can either be an absolute file
	 * path as string or uri or a {@link WorkspaceFolder workspace folder}, which is the
	 * preferred way of creating the relative pattern.
	 */
	export class RelativePattern {

		/**
		 * A base file path to which this pattern will be matched against relatively. The
		 * file path must be absolute, should not have any trailing path separators and
		 * not include any relative segments (`.` or `..`).
		 */
		baseUri: Uri;

		/**
		 * A base file path to which this pattern will be matched against relatively.
		 *
		 * This matches the `fsPath` value of {@link RelativePattern.baseUri}.
		 *
		 * *Note:* updating this value will update {@link RelativePattern.baseUri} to
		 * be a uri with `file` scheme.
		 *
		 * @deprecated This property is deprecated, please use {@link RelativePattern.baseUri} instead.
		 */
		base: string;

		/**
		 * A file glob pattern like `*.{ts,js}` that will be matched on file paths
		 * relative to the base path.
		 *
		 * Example: Given a base of `/home/work/folder` and a file path of `/home/work/folder/index.js`,
		 * the file glob pattern will match on `index.js`.
		 */
		pattern: string;

		/**
		 * Creates a new relative pattern object with a base file path and pattern to match. This pattern
		 * will be matched on file paths relative to the base.
		 *
		 * Example:
		 * ```ts
		 * const folder = vscode.workspace.workspaceFolders?.[0];
		 * if (folder) {
		 *
		 *   // Match any TypeScript file in the root of this workspace folder
		 *   const pattern1 = new vscode.RelativePattern(folder, '*.ts');
		 *
		 *   // Match any TypeScript file in `someFolder` inside this workspace folder
		 *   const pattern2 = new vscode.RelativePattern(folder, 'someFolder/*.ts');
		 * }
		 * ```
		 *
		 * @param base A base to which this pattern will be matched against relatively. It is recommended
		 * to pass in a {@link WorkspaceFolder workspace folder} if the pattern should match inside the workspace.
		 * Otherwise, a uri or string should only be used if the pattern is for a file path outside the workspace.
		 * @param pattern A file glob pattern like `*.{ts,js}` that will be matched on paths relative to the base.
		 */
		constructor(base: WorkspaceFolder | Uri | string, pattern: string);
	}

	/**
	 * A file glob pattern to match file paths against. This can either be a glob pattern string
	 * (like `**/*.{ts,js}` or `*.{ts,js}`) or a {@link RelativePattern relative pattern}.
	 *
	 * Glob patterns can have the following syntax:
	 * * `*` to match zero or more characters in a path segment
	 * * `?` to match on one character in a path segment
	 * * `**` to match any number of path segments, including none
	 * * `{}` to group conditions (e.g. `**/*.{ts,js}` matches all TypeScript and JavaScript files)
	 * * `[]` to declare a range of characters to match in a path segment (e.g., `example.[0-9]` to match on `example.0`, `example.1`, )
	 * * `[!...]` to negate a range of characters to match in a path segment (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not `example.0`)
	 *
	 * Note: a backslash (`\`) is not valid within a glob pattern. If you have an existing file
	 * path to match against, consider to use the {@link RelativePattern relative pattern} support
	 * that takes care of converting any backslash into slash. Otherwise, make sure to convert
	 * any backslash to slash when creating the glob pattern.
	 */
	export type GlobPattern = string | RelativePattern;

	/**
	 * A document filter denotes a document by different properties like
	 * the {@link TextDocument.languageId language}, the {@link Uri.scheme scheme} of
	 * its resource, or a glob-pattern that is applied to the {@link TextDocument.fileName path}.
	 *
	 * @example <caption>A language filter that applies to typescript files on disk</caption>
	 * { language: 'typescript', scheme: 'file' }
	 *
	 * @example <caption>A language filter that applies to all package.json paths</caption>
	 * { language: 'json', pattern: '**/package.json' }
	 */
	export interface DocumentFilter {

		/**
		 * A language id, like `typescript`.
		 */
		readonly language?: string;

		/**
		 * The {@link NotebookDocument.notebookType type} of a notebook, like `jupyter-notebook`. This allows
		 * to narrow down on the type of a notebook that a {@link NotebookCell.document cell document} belongs to.
		 *
		 * *Note* that setting the `notebookType`-property changes how `scheme` and `pattern` are interpreted. When set
		 * they are evaluated against the {@link NotebookDocument.uri notebook uri}, not the document uri.
		 *
		 * @example <caption>Match python document inside jupyter notebook that aren't stored yet (`untitled`)</caption>
		 * { language: 'python', notebookType: 'jupyter-notebook', scheme: 'untitled' }
		 */
		readonly notebookType?: string;

		/**
		 * A Uri {@link Uri.scheme scheme}, like `file` or `untitled`.
		 */
		readonly scheme?: string;

		/**
		 * A {@link GlobPattern glob pattern} that is matched on the absolute path of the document. Use a {@link RelativePattern relative pattern}
		 * to filter documents to a {@link WorkspaceFolder workspace folder}.
		 */
		readonly pattern?: GlobPattern;
	}

	/**
	 * A language selector is the combination of one or many language identifiers
	 * and {@link DocumentFilter language filters}.
	 *
	 * *Note* that a document selector that is just a language identifier selects *all*
	 * documents, even those that are not saved on disk. Only use such selectors when
	 * a feature works without further context, e.g. without the need to resolve related
	 * 'files'.
	 *
	 * @example
	 * let sel:DocumentSelector = { scheme: 'file', language: 'typescript' };
	 */
	export type DocumentSelector = DocumentFilter | string | ReadonlyArray<DocumentFilter | string>;

	/**
	 * A provider result represents the values a provider, like the {@linkcode HoverProvider},
	 * may return. For once this is the actual result type `T`, like `Hover`, or a thenable that resolves
	 * to that type `T`. In addition, `null` and `undefined` can be returned - either directly or from a
	 * thenable.
	 *
	 * The snippets below are all valid implementations of the {@linkcode HoverProvider}:
	 *
	 * ```ts
	 * let a: HoverProvider = {
	 * 	provideHover(doc, pos, token): ProviderResult<Hover> {
	 * 		return new Hover('Hello World');
	 * 	}
	 * }
	 *
	 * let b: HoverProvider = {
	 * 	provideHover(doc, pos, token): ProviderResult<Hover> {
	 * 		return new Promise(resolve => {
	 * 			resolve(new Hover('Hello World'));
	 * 	 	});
	 * 	}
	 * }
	 *
	 * let c: HoverProvider = {
	 * 	provideHover(doc, pos, token): ProviderResult<Hover> {
	 * 		return; // undefined
	 * 	}
	 * }
	 * ```
	 */
	export type ProviderResult<T> = T | undefined | null | Thenable<T | undefined | null>;

	/**
	 * Kind of a code action.
	 *
	 * Kinds are a hierarchical list of identifiers separated by `.`, e.g. `"refactor.extract.function"`.
	 *
	 * Code action kinds are used by the editor for UI elements such as the refactoring context menu. Users
	 * can also trigger code actions with a specific kind with the `editor.action.codeAction` command.
	 */
	export class CodeActionKind {
		/**
		 * Empty kind.
		 */
		static readonly Empty: CodeActionKind;

		/**
		 * Base kind for quickfix actions: `quickfix`.
		 *
		 * Quick fix actions address a problem in the code and are shown in the normal code action context menu.
		 */
		static readonly QuickFix: CodeActionKind;

		/**
		 * Base kind for refactoring actions: `refactor`
		 *
		 * Refactoring actions are shown in the refactoring context menu.
		 */
		static readonly Refactor: CodeActionKind;

		/**
		 * Base kind for refactoring extraction actions: `refactor.extract`
		 *
		 * Example extract actions:
		 *
		 * - Extract method
		 * - Extract function
		 * - Extract variable
		 * - Extract interface from class
		 * - ...
		 */
		static readonly RefactorExtract: CodeActionKind;

		/**
		 * Base kind for refactoring inline actions: `refactor.inline`
		 *
		 * Example inline actions:
		 *
		 * - Inline function
		 * - Inline variable
		 * - Inline constant
		 * - ...
		 */
		static readonly RefactorInline: CodeActionKind;

		/**
		 * Base kind for refactoring move actions: `refactor.move`
		 *
		 * Example move actions:
		 *
		 * - Move a function to a new file
		 * - Move a property between classes
		 * - Move method to base class
		 * - ...
		 */
		static readonly RefactorMove: CodeActionKind;

		/**
		 * Base kind for refactoring rewrite actions: `refactor.rewrite`
		 *
		 * Example rewrite actions:
		 *
		 * - Convert JavaScript function to class
		 * - Add or remove parameter
		 * - Encapsulate field
		 * - Make method static
		 * - ...
		 */
		static readonly RefactorRewrite: CodeActionKind;

		/**
		 * Base kind for source actions: `source`
		 *
		 * Source code actions apply to the entire file. They must be explicitly requested and will not show in the
		 * normal [lightbulb](https://code.visualstudio.com/docs/editor/editingevolved#_code-action) menu. Source actions
		 * can be run on save using `editor.codeActionsOnSave` and are also shown in the `source` context menu.
		 */
		static readonly Source: CodeActionKind;

		/**
		 * Base kind for an organize imports source action: `source.organizeImports`.
		 */
		static readonly SourceOrganizeImports: CodeActionKind;

		/**
		 * Base kind for auto-fix source actions: `source.fixAll`.
		 *
		 * Fix all actions automatically fix errors that have a clear fix that do not require user input.
		 * They should not suppress errors or perform unsafe fixes such as generating new types or classes.
		 */
		static readonly SourceFixAll: CodeActionKind;

		/**
		 * Base kind for all code actions applying to the entire notebook's scope. CodeActionKinds using
		 * this should always begin with `notebook.`
		 *
		 * This requires that new CodeActions be created for it and contributed via extensions.
		 * Pre-existing kinds can not just have the new `notebook.` prefix added to them, as the functionality
		 * is unique to the full-notebook scope.
		 *
		 * Notebook CodeActionKinds can be initialized as either of the following (both resulting in `notebook.source.xyz`):
		 * - `const newKind =  CodeActionKind.Notebook.append(CodeActionKind.Source.append('xyz').value)`
		 * - `const newKind =  CodeActionKind.Notebook.append('source.xyz')`
		 *
		 * Example Kinds/Actions:
		 * - `notebook.source.organizeImports` (might move all imports to a new top cell)
		 * - `notebook.source.normalizeVariableNames` (might rename all variables to a standardized casing format)
		 */
		static readonly Notebook: CodeActionKind;

		/**
		 * Private constructor, use static `CodeActionKind.XYZ` to derive from an existing code action kind.
		 *
		 * @param value The value of the kind, such as `refactor.extract.function`.
		 */
		private constructor(value: string);

		/**
		 * String value of the kind, e.g. `"refactor.extract.function"`.
		 */
		readonly value: string;

		/**
		 * Create a new kind by appending a more specific selector to the current kind.
		 *
		 * Does not modify the current kind.
		 */
		append(parts: string): CodeActionKind;

		/**
		 * Checks if this code action kind intersects `other`.
		 *
		 * The kind `"refactor.extract"` for example intersects `refactor`, `"refactor.extract"` and `"refactor.extract.function"`,
		 * but not `"unicorn.refactor.extract"`, or `"refactor.extractAll"`.
		 *
		 * @param other Kind to check.
		 */
		intersects(other: CodeActionKind): boolean;

		/**
		 * Checks if `other` is a sub-kind of this `CodeActionKind`.
		 *
		 * The kind `"refactor.extract"` for example contains `"refactor.extract"` and ``"refactor.extract.function"`,
		 * but not `"unicorn.refactor.extract"`, or `"refactor.extractAll"` or `refactor`.
		 *
		 * @param other Kind to check.
		 */
		contains(other: CodeActionKind): boolean;
	}

	/**
	 * The reason why code actions were requested.
	 */
	export enum CodeActionTriggerKind {
		/**
		 * Code actions were explicitly requested by the user or by an extension.
		 */
		Invoke = 1,

		/**
		 * Code actions were requested automatically.
		 *
		 * This typically happens when current selection in a file changes, but can
		 * also be triggered when file content changes.
		 */
		Automatic = 2,
	}

	/**
	 * Contains additional diagnostic information about the context in which
	 * a {@link CodeActionProvider.provideCodeActions code action} is run.
	 */
	export interface CodeActionContext {
		/**
		 * The reason why code actions were requested.
		 */
		readonly triggerKind: CodeActionTriggerKind;

		/**
		 * An array of diagnostics.
		 */
		readonly diagnostics: readonly Diagnostic[];

		/**
		 * Requested kind of actions to return.
		 *
		 * Actions not of this kind are filtered out before being shown by the [lightbulb](https://code.visualstudio.com/docs/editor/editingevolved#_code-action).
		 */
		readonly only: CodeActionKind | undefined;
	}

	/**
	 * A code action represents a change that can be performed in code, e.g. to fix a problem or
	 * to refactor code.
	 *
	 * A CodeAction must set either {@linkcode CodeAction.edit edit} and/or a {@linkcode CodeAction.command command}. If both are supplied, the `edit` is applied first, then the command is executed.
	 */
	export class CodeAction {

		/**
		 * A short, human-readable, title for this code action.
		 */
		title: string;

		/**
		 * A {@link WorkspaceEdit workspace edit} this code action performs.
		 */
		edit?: WorkspaceEdit;

		/**
		 * {@link Diagnostic Diagnostics} that this code action resolves.
		 */
		diagnostics?: Diagnostic[];

		/**
		 * A {@link Command} this code action executes.
		 *
		 * If this command throws an exception, the editor displays the exception message to users in the editor at the
		 * current cursor position.
		 */
		command?: Command;

		/**
		 * {@link CodeActionKind Kind} of the code action.
		 *
		 * Used to filter code actions.
		 */
		kind?: CodeActionKind;

		/**
		 * Marks this as a preferred action. Preferred actions are used by the `auto fix` command and can be targeted
		 * by keybindings.
		 *
		 * A quick fix should be marked preferred if it properly addresses the underlying error.
		 * A refactoring should be marked preferred if it is the most reasonable choice of actions to take.
		 */
		isPreferred?: boolean;

		/**
		 * Marks that the code action cannot currently be applied.
		 *
		 * - Disabled code actions are not shown in automatic [lightbulb](https://code.visualstudio.com/docs/editor/editingevolved#_code-action)
		 * code action menu.
		 *
		 * - Disabled actions are shown as faded out in the code action menu when the user request a more specific type
		 * of code action, such as refactorings.
		 *
		 * - If the user has a [keybinding](https://code.visualstudio.com/docs/editor/refactoring#_keybindings-for-code-actions)
		 * that auto applies a code action and only a disabled code actions are returned, the editor will show the user an
		 * error message with `reason` in the editor.
		 */
		disabled?: {
			/**
			 * Human readable description of why the code action is currently disabled.
			 *
			 * This is displayed in the code actions UI.
			 */
			readonly reason: string;
		};

		/**
		 * Creates a new code action.
		 *
		 * A code action must have at least a {@link CodeAction.title title} and {@link CodeAction.edit edits}
		 * and/or a {@link CodeAction.command command}.
		 *
		 * @param title The title of the code action.
		 * @param kind The kind of the code action.
		 */
		constructor(title: string, kind?: CodeActionKind);
	}

	/**
	 * Provides contextual actions for code. Code actions typically either fix problems or beautify/refactor code.
	 *
	 * Code actions are surfaced to users in a few different ways:
	 *
	 * - The [lightbulb](https://code.visualstudio.com/docs/editor/editingevolved#_code-action) feature, which shows
	 *   a list of code actions at the current cursor position. The lightbulb's list of actions includes both quick fixes
	 *   and refactorings.
	 * - As commands that users can run, such as `Refactor`. Users can run these from the command palette or with keybindings.
	 * - As source actions, such `Organize Imports`.
	 * - {@link CodeActionKind.QuickFix Quick fixes} are shown in the problems view.
	 * - Change applied on save by the `editor.codeActionsOnSave` setting.
	 */
	export interface CodeActionProvider<T extends CodeAction = CodeAction> {
		/**
		 * Get code actions for a given range in a document.
		 *
		 * Only return code actions that are relevant to user for the requested range. Also keep in mind how the
		 * returned code actions will appear in the UI. The lightbulb widget and `Refactor` commands for instance show
		 * returned code actions as a list, so do not return a large number of code actions that will overwhelm the user.
		 *
		 * @param document The document in which the command was invoked.
		 * @param range The selector or range for which the command was invoked. This will always be a
		 * {@link Selection selection} if the actions are being requested in the currently active editor.
		 * @param context Provides additional information about what code actions are being requested. You can use this
		 * to see what specific type of code actions are being requested by the editor in order to return more relevant
		 * actions and avoid returning irrelevant code actions that the editor will discard.
		 * @param token A cancellation token.
		 *
		 * @returns An array of code actions, such as quick fixes or refactorings. The lack of a result can be signaled
		 * by returning `undefined`, `null`, or an empty array.
		 *
		 * We also support returning `Command` for legacy reasons, however all new extensions should return
		 * `CodeAction` object instead.
		 */
		provideCodeActions(document: TextDocument, range: Range | Selection, context: CodeActionContext, token: CancellationToken): ProviderResult<Array<Command | T>>;

		/**
		 * Given a code action fill in its {@linkcode CodeAction.edit edit}-property. Changes to
		 * all other properties, like title, are ignored. A code action that has an edit
		 * will not be resolved.
		 *
		 * *Note* that a code action provider that returns commands, not code actions, cannot successfully
		 * implement this function. Returning commands is deprecated and instead code actions should be
		 * returned.
		 *
		 * @param codeAction A code action.
		 * @param token A cancellation token.
		 * @returns The resolved code action or a thenable that resolves to such. It is OK to return the given
		 * `item`. When no result is returned, the given `item` will be used.
		 */
		resolveCodeAction?(codeAction: T, token: CancellationToken): ProviderResult<T>;
	}

	/**
	 * Metadata about the type of code actions that a {@link CodeActionProvider} provides.
	 */
	export interface CodeActionProviderMetadata {
		/**
		 * List of {@link CodeActionKind CodeActionKinds} that a {@link CodeActionProvider} may return.
		 *
		 * This list is used to determine if a given `CodeActionProvider` should be invoked or not.
		 * To avoid unnecessary computation, every `CodeActionProvider` should list use `providedCodeActionKinds`. The
		 * list of kinds may either be generic, such as `[CodeActionKind.Refactor]`, or list out every kind provided,
		 * such as `[CodeActionKind.Refactor.Extract.append('function'), CodeActionKind.Refactor.Extract.append('constant'), ...]`.
		 */
		readonly providedCodeActionKinds?: readonly CodeActionKind[];

		/**
		 * Static documentation for a class of code actions.
		 *
		 * Documentation from the provider is shown in the code actions menu if either:
		 *
		 * - Code actions of `kind` are requested by the editor. In this case, the editor will show the documentation that
		 *   most closely matches the requested code action kind. For example, if a provider has documentation for
		 *   both `Refactor` and `RefactorExtract`, when the user requests code actions for `RefactorExtract`,
		 *   the editor will use the documentation for `RefactorExtract` instead of the documentation for `Refactor`.
		 *
		 * - Any code actions of `kind` are returned by the provider.
		 *
		 * At most one documentation entry will be shown per provider.
		 */
		readonly documentation?: ReadonlyArray<{
			/**
			 * The kind of the code action being documented.
			 *
			 * If the kind is generic, such as `CodeActionKind.Refactor`, the documentation will be shown whenever any
			 * refactorings are returned. If the kind if more specific, such as `CodeActionKind.RefactorExtract`, the
			 * documentation will only be shown when extract refactoring code actions are returned.
			 */
			readonly kind: CodeActionKind;

			/**
			 * Command that displays the documentation to the user.
			 *
			 * This can display the documentation directly in the editor or open a website using {@linkcode env.openExternal};
			 *
			 * The title of this documentation code action is taken from {@linkcode Command.title}
			 */
			readonly command: Command;
		}>;
	}

	/**
	 * A code lens represents a {@link Command} that should be shown along with
	 * source text, like the number of references, a way to run tests, etc.
	 *
	 * A code lens is _unresolved_ when no command is associated to it. For performance
	 * reasons the creation of a code lens and resolving should be done to two stages.
	 *
	 * @see {@link CodeLensProvider.provideCodeLenses}
	 * @see {@link CodeLensProvider.resolveCodeLens}
	 */
	export class CodeLens {

		/**
		 * The range in which this code lens is valid. Should only span a single line.
		 */
		range: Range;

		/**
		 * The command this code lens represents.
		 */
		command?: Command;

		/**
		 * `true` when there is a command associated.
		 */
		readonly isResolved: boolean;

		/**
		 * Creates a new code lens object.
		 *
		 * @param range The range to which this code lens applies.
		 * @param command The command associated to this code lens.
		 */
		constructor(range: Range, command?: Command);
	}

	/**
	 * A code lens provider adds {@link Command commands} to source text. The commands will be shown
	 * as dedicated horizontal lines in between the source text.
	 */
	export interface CodeLensProvider<T extends CodeLens = CodeLens> {

		/**
		 * An optional event to signal that the code lenses from this provider have changed.
		 */
		onDidChangeCodeLenses?: Event<void>;

		/**
		 * Compute a list of {@link CodeLens lenses}. This call should return as fast as possible and if
		 * computing the commands is expensive implementors should only return code lens objects with the
		 * range set and implement {@link CodeLensProvider.resolveCodeLens resolve}.
		 *
		 * @param document The document in which the command was invoked.
		 * @param token A cancellation token.
		 * @returns An array of code lenses or a thenable that resolves to such. The lack of a result can be
		 * signaled by returning `undefined`, `null`, or an empty array.
		 */
		provideCodeLenses(document: TextDocument, token: CancellationToken): ProviderResult<T[]>;

		/**
		 * This function will be called for each visible code lens, usually when scrolling and after
		 * calls to {@link CodeLensProvider.provideCodeLenses compute}-lenses.
		 *
		 * @param codeLens Code lens that must be resolved.
		 * @param token A cancellation token.
		 * @returns The given, resolved code lens or thenable that resolves to such.
		 */
		resolveCodeLens?(codeLens: T, token: CancellationToken): ProviderResult<T>;
	}

	/**
	 * Information about where a symbol is defined.
	 *
	 * Provides additional metadata over normal {@link Location} definitions, including the range of
	 * the defining symbol
	 */
	export type DefinitionLink = LocationLink;

	/**
	 * The definition of a symbol represented as one or many {@link Location locations}.
	 * For most programming languages there is only one location at which a symbol is
	 * defined.
	 */
	export type Definition = Location | Location[];

	/**
	 * The definition provider interface defines the contract between extensions and
	 * the [go to definition](https://code.visualstudio.com/docs/editor/editingevolved#_go-to-definition)
	 * and peek definition features.
	 */
	export interface DefinitionProvider {

		/**
		 * Provide the definition of the symbol at the given position and document.
		 *
		 * @param document The document in which the command was invoked.
		 * @param position The position at which the command was invoked.
		 * @param token A cancellation token.
		 * @returns A definition or a thenable that resolves to such. The lack of a result can be
		 * signaled by returning `undefined` or `null`.
		 */
		provideDefinition(document: TextDocument, position: Position, token: CancellationToken): ProviderResult<Definition | DefinitionLink[]>;
	}

	/**
	 * The implementation provider interface defines the contract between extensions and
	 * the go to implementation feature.
	 */
	export interface ImplementationProvider {

		/**
		 * Provide the implementations of the symbol at the given position and document.
		 *
		 * @param document The document in which the command was invoked.
		 * @param position The position at which the command was invoked.
		 * @param token A cancellation token.
		 * @returns A definition or a thenable that resolves to such. The lack of a result can be
		 * signaled by returning `undefined` or `null`.
		 */
		provideImplementation(document: TextDocument, position: Position, token: CancellationToken): ProviderResult<Definition | DefinitionLink[]>;
	}

	/**
	 * The type definition provider defines the contract between extensions and
	 * the go to type definition feature.
	 */
	export interface TypeDefinitionProvider {

		/**
		 * Provide the type definition of the symbol at the given position and document.
		 *
		 * @param document The document in which the command was invoked.
		 * @param position The position at which the command was invoked.
		 * @param token A cancellation token.
		 * @returns A definition or a thenable that resolves to such. The lack of a result can be
		 * signaled by returning `undefined` or `null`.
		 */
		provideTypeDefinition(document: TextDocument, position: Position, token: CancellationToken): ProviderResult<Definition | DefinitionLink[]>;
	}

	/**
	 * The declaration of a symbol representation as one or many {@link Location locations}
	 * or {@link LocationLink location links}.
	 */
	export type Declaration = Location | Location[] | LocationLink[];

	/**
	 * The declaration provider interface defines the contract between extensions and
	 * the go to declaration feature.
	 */
	export interface DeclarationProvider {

		/**
		 * Provide the declaration of the symbol at the given position and document.
		 *
		 * @param document The document in which the command was invoked.
		 * @param position The position at which the command was invoked.
		 * @param token A cancellation token.
		 * @returns A declaration or a thenable that resolves to such. The lack of a result can be
		 * signaled by returning `undefined` or `null`.
		 */
		provideDeclaration(document: TextDocument, position: Position, token: CancellationToken): ProviderResult<Declaration>;
	}

	/**
	 * Human-readable text that supports formatting via the [markdown syntax](https://commonmark.org).
	 *
	 * Rendering of {@link ThemeIcon theme icons} via the `$(<name>)`-syntax is supported
	 * when the {@linkcode supportThemeIcons} is set to `true`.
	 *
	 * Rendering of embedded html is supported when {@linkcode supportHtml} is set to `true`.
	 */
	export class MarkdownString {

		/**
		 * The markdown string.
		 */
		value: string;

		/**
		 * Indicates that this markdown string is from a trusted source. Only *trusted*
		 * markdown supports links that execute commands, e.g. `[Run it](command:myCommandId)`.
		 *
		 * Defaults to `false` (commands are disabled).
		 */
		isTrusted?: boolean | {
			/**
			 * A set of commend ids that are allowed to be executed by this markdown string.
			 */
			readonly enabledCommands: readonly string[];
		};

		/**
		 * Indicates that this markdown string can contain {@link ThemeIcon ThemeIcons}, e.g. `$(zap)`.
		 */
		supportThemeIcons?: boolean;

		/**
		 * Indicates that this markdown string can contain raw html tags. Defaults to `false`.
		 *
		 * When `supportHtml` is false, the markdown renderer will strip out any raw html tags
		 * that appear in the markdown text. This means you can only use markdown syntax for rendering.
		 *
		 * When `supportHtml` is true, the markdown render will also allow a safe subset of html tags
		 * and attributes to be rendered. See https://github.com/microsoft/vscode/blob/6d2920473c6f13759c978dd89104c4270a83422d/src/vs/base/browser/markdownRenderer.ts#L296
		 * for a list of all supported tags and attributes.
		 */
		supportHtml?: boolean;

		/**
		 * Uri that relative paths are resolved relative to.
		 *
		 * If the `baseUri` ends with `/`, it is considered a directory and relative paths in the markdown are resolved relative to that directory:
		 *
		 * ```ts
		 * const md = new vscode.MarkdownString(`[link](./file.js)`);
		 * md.baseUri = vscode.Uri.file('/path/to/dir/');
		 * // Here 'link' in the rendered markdown resolves to '/path/to/dir/file.js'
		 * ```
		 *
		 * If the `baseUri` is a file, relative paths in the markdown are resolved relative to the parent dir of that file:
		 *
		 * ```ts
		 * const md = new vscode.MarkdownString(`[link](./file.js)`);
		 * md.baseUri = vscode.Uri.file('/path/to/otherFile.js');
		 * // Here 'link' in the rendered markdown resolves to '/path/to/file.js'
		 * ```
		 */
		baseUri?: Uri;

		/**
		 * Creates a new markdown string with the given value.
		 *
		 * @param value Optional, initial value.
		 * @param supportThemeIcons Optional, Specifies whether {@link ThemeIcon ThemeIcons} are supported within the {@linkcode MarkdownString}.
		 */
		constructor(value?: string, supportThemeIcons?: boolean);

		/**
		 * Appends and escapes the given string to this markdown string.
		 * @param value Plain text.
		 */
		appendText(value: string): MarkdownString;

		/**
		 * Appends the given string 'as is' to this markdown string. When {@linkcode MarkdownString.supportThemeIcons supportThemeIcons} is `true`, {@link ThemeIcon ThemeIcons} in the `value` will be iconified.
		 * @param value Markdown string.
		 */
		appendMarkdown(value: string): MarkdownString;

		/**
		 * Appends the given string as codeblock using the provided language.
		 * @param value A code snippet.
		 * @param language An optional {@link languages.getLanguages language identifier}.
		 */
		appendCodeblock(value: string, language?: string): MarkdownString;
	}

	/**
	 * MarkedString can be used to render human-readable text. It is either a markdown string
	 * or a code-block that provides a language and a code snippet. Note that
	 * markdown strings will be sanitized - that means html will be escaped.
	 *
	 * @deprecated This type is deprecated, please use {@linkcode MarkdownString} instead.
	 */
	export type MarkedString = string | {
		/**
		 * The language of a markdown code block
		 * @deprecated please use {@linkcode MarkdownString} instead
		 */
		language: string;
		/**
		 * The code snippet of a markdown code block.
		 * @deprecated please use {@linkcode MarkdownString} instead
		 */
		value: string;
	};

	/**
	 * A hover represents additional information for a symbol or word. Hovers are
	 * rendered in a tooltip-like widget.
	 */
	export class Hover {

		/**
		 * The contents of this hover.
		 */
		contents: Array<MarkdownString | MarkedString>;

		/**
		 * The range to which this hover applies. When missing, the
		 * editor will use the range at the current position or the
		 * current position itself.
		 */
		range?: Range;

		/**
		 * Creates a new hover object.
		 *
		 * @param contents The contents of the hover.
		 * @param range The range to which the hover applies.
		 */
		constructor(contents: MarkdownString | MarkedString | Array<MarkdownString | MarkedString>, range?: Range);
	}

	/**
	 * The hover provider interface defines the contract between extensions and
	 * the [hover](https://code.visualstudio.com/docs/editor/intellisense)-feature.
	 */
	export interface HoverProvider {

		/**
		 * Provide a hover for the given position and document. Multiple hovers at the same
		 * position will be merged by the editor. A hover can have a range which defaults
		 * to the word range at the position when omitted.
		 *
		 * @param document The document in which the command was invoked.
		 * @param position The position at which the command was invoked.
		 * @param token A cancellation token.
		 * @returns A hover or a thenable that resolves to such. The lack of a result can be
		 * signaled by returning `undefined` or `null`.
		 */
		provideHover(document: TextDocument, position: Position, token: CancellationToken): ProviderResult<Hover>;
	}

	/**
	 * An EvaluatableExpression represents an expression in a document that can be evaluated by an active debugger or runtime.
	 * The result of this evaluation is shown in a tooltip-like widget.
	 * If only a range is specified, the expression will be extracted from the underlying document.
	 * An optional expression can be used to override the extracted expression.
	 * In this case the range is still used to highlight the range in the document.
	 */
	export class EvaluatableExpression {

		/**
		 * The range is used to extract the evaluatable expression from the underlying document and to highlight it.
		 */
		readonly range: Range;

		/**
		 * If specified the expression overrides the extracted expression.
		 */
		readonly expression?: string | undefined;

		/**
		 * Creates a new evaluatable expression object.
		 *
		 * @param range The range in the underlying document from which the evaluatable expression is extracted.
		 * @param expression If specified overrides the extracted expression.
		 */
		constructor(range: Range, expression?: string);
	}

	/**
	 * The evaluatable expression provider interface defines the contract between extensions and
	 * the debug hover. In this contract the provider returns an evaluatable expression for a given position
	 * in a document and the editor evaluates this expression in the active debug session and shows the result in a debug hover.
	 */
	export interface EvaluatableExpressionProvider {

		/**
		 * Provide an evaluatable expression for the given document and position.
		 * The editor will evaluate this expression in the active debug session and will show the result in the debug hover.
		 * The expression can be implicitly specified by the range in the underlying document or by explicitly returning an expression.
		 *
		 * @param document The document for which the debug hover is about to appear.
		 * @param position The line and character position in the document where the debug hover is about to appear.
		 * @param token A cancellation token.
		 * @returns An EvaluatableExpression or a thenable that resolves to such. The lack of a result can be
		 * signaled by returning `undefined` or `null`.
		 */
		provideEvaluatableExpression(document: TextDocument, position: Position, token: CancellationToken): ProviderResult<EvaluatableExpression>;
	}

	/**
	 * Provide inline value as text.
	 */
	export class InlineValueText {
		/**
		 * The document range for which the inline value applies.
		 */
		readonly range: Range;
		/**
		 * The text of the inline value.
		 */
		readonly text: string;
		/**
		 * Creates a new InlineValueText object.
		 *
		 * @param range The document line where to show the inline value.
		 * @param text The value to be shown for the line.
		 */
		constructor(range: Range, text: string);
	}

	/**
	 * Provide inline value through a variable lookup.
	 * If only a range is specified, the variable name will be extracted from the underlying document.
	 * An optional variable name can be used to override the extracted name.
	 */
	export class InlineValueVariableLookup {
		/**
		 * The document range for which the inline value applies.
		 * The range is used to extract the variable name from the underlying document.
		 */
		readonly range: Range;
		/**
		 * If specified the name of the variable to look up.
		 */
		readonly variableName?: string | undefined;
		/**
		 * How to perform the lookup.
		 */
		readonly caseSensitiveLookup: boolean;
		/**
		 * Creates a new InlineValueVariableLookup object.
		 *
		 * @param range The document line where to show the inline value.
		 * @param variableName The name of the variable to look up.
		 * @param caseSensitiveLookup How to perform the lookup. If missing lookup is case sensitive.
		 */
		constructor(range: Range, variableName?: string, caseSensitiveLookup?: boolean);
	}

	/**
	 * Provide an inline value through an expression evaluation.
	 * If only a range is specified, the expression will be extracted from the underlying document.
	 * An optional expression can be used to override the extracted expression.
	 */
	export class InlineValueEvaluatableExpression {
		/**
		 * The document range for which the inline value applies.
		 * The range is used to extract the evaluatable expression from the underlying document.
		 */
		readonly range: Range;
		/**
		 * If specified the expression overrides the extracted expression.
		 */
		readonly expression?: string | undefined;
		/**
		 * Creates a new InlineValueEvaluatableExpression object.
		 *
		 * @param range The range in the underlying document from which the evaluatable expression is extracted.
		 * @param expression If specified overrides the extracted expression.
		 */
		constructor(range: Range, expression?: string);
	}

	/**
	 * Inline value information can be provided by different means:
	 * - directly as a text value (class InlineValueText).
	 * - as a name to use for a variable lookup (class InlineValueVariableLookup)
	 * - as an evaluatable expression (class InlineValueEvaluatableExpression)
	 * The InlineValue types combines all inline value types into one type.
	 */
	export type InlineValue = InlineValueText | InlineValueVariableLookup | InlineValueEvaluatableExpression;

	/**
	 * A value-object that contains contextual information when requesting inline values from a InlineValuesProvider.
	 */
	export interface InlineValueContext {

		/**
		 * The stack frame (as a DAP Id) where the execution has stopped.
		 */
		readonly frameId: number;

		/**
		 * The document range where execution has stopped.
		 * Typically the end position of the range denotes the line where the inline values are shown.
		 */
		readonly stoppedLocation: Range;
	}

	/**
	 * The inline values provider interface defines the contract between extensions and the editor's debugger inline values feature.
	 * In this contract the provider returns inline value information for a given document range
	 * and the editor shows this information in the editor at the end of lines.
	 */
	export interface InlineValuesProvider {

		/**
		 * An optional event to signal that inline values have changed.
		 * @see {@link EventEmitter}
		 */
		onDidChangeInlineValues?: Event<void> | undefined;

		/**
		 * Provide "inline value" information for a given document and range.
		 * The editor calls this method whenever debugging stops in the given document.
		 * The returned inline values information is rendered in the editor at the end of lines.
		 *
		 * @param document The document for which the inline values information is needed.
		 * @param viewPort The visible document range for which inline values should be computed.
		 * @param context A bag containing contextual information like the current location.
		 * @param token A cancellation token.
		 * @returns An array of InlineValueDescriptors or a thenable that resolves to such. The lack of a result can be
		 * signaled by returning `undefined` or `null`.
		 */
		provideInlineValues(document: TextDocument, viewPort: Range, context: InlineValueContext, token: CancellationToken): ProviderResult<InlineValue[]>;
	}

	/**
	 * A document highlight kind.
	 */
	export enum DocumentHighlightKind {

		/**
		 * A textual occurrence.
		 */
		Text = 0,

		/**
		 * Read-access of a symbol, like reading a variable.
		 */
		Read = 1,

		/**
		 * Write-access of a symbol, like writing to a variable.
		 */
		Write = 2
	}

	/**
	 * A document highlight is a range inside a text document which deserves
	 * special attention. Usually a document highlight is visualized by changing
	 * the background color of its range.
	 */
	export class DocumentHighlight {

		/**
		 * The range this highlight applies to.
		 */
		range: Range;

		/**
		 * The highlight kind, default is {@link DocumentHighlightKind.Text text}.
		 */
		kind?: DocumentHighlightKind;

		/**
		 * Creates a new document highlight object.
		 *
		 * @param range The range the highlight applies to.
		 * @param kind The highlight kind, default is {@link DocumentHighlightKind.Text text}.
		 */
		constructor(range: Range, kind?: DocumentHighlightKind);
	}

	/**
	 * The document highlight provider interface defines the contract between extensions and
	 * the word-highlight-feature.
	 */
	export interface DocumentHighlightProvider {

		/**
		 * Provide a set of document highlights, like all occurrences of a variable or
		 * all exit-points of a function.
		 *
		 * @param document The document in which the command was invoked.
		 * @param position The position at which the command was invoked.
		 * @param token A cancellation token.
		 * @returns An array of document highlights or a thenable that resolves to such. The lack of a result can be
		 * signaled by returning `undefined`, `null`, or an empty array.
		 */
		provideDocumentHighlights(document: TextDocument, position: Position, token: CancellationToken): ProviderResult<DocumentHighlight[]>;
	}

	/**
	 * A symbol kind.
	 */
	export enum SymbolKind {
		/**
		 * The `File` symbol kind.
		 */
		File = 0,
		/**
		 * The `Module` symbol kind.
		 */
		Module = 1,
		/**
		 * The `Namespace` symbol kind.
		 */
		Namespace = 2,
		/**
		 * The `Package` symbol kind.
		 */
		Package = 3,
		/**
		 * The `Class` symbol kind.
		 */
		Class = 4,
		/**
		 * The `Method` symbol kind.
		 */
		Method = 5,
		/**
		 * The `Property` symbol kind.
		 */
		Property = 6,
		/**
		 * The `Field` symbol kind.
		 */
		Field = 7,
		/**
		 * The `Constructor` symbol kind.
		 */
		Constructor = 8,
		/**
		 * The `Enum` symbol kind.
		 */
		Enum = 9,
		/**
		 * The `Interface` symbol kind.
		 */
		Interface = 10,
		/**
		 * The `Function` symbol kind.
		 */
		Function = 11,
		/**
		 * The `Variable` symbol kind.
		 */
		Variable = 12,
		/**
		 * The `Constant` symbol kind.
		 */
		Constant = 13,
		/**
		 * The `String` symbol kind.
		 */
		String = 14,
		/**
		 * The `Number` symbol kind.
		 */
		Number = 15,
		/**
		 * The `Boolean` symbol kind.
		 */
		Boolean = 16,
		/**
		 * The `Array` symbol kind.
		 */
		Array = 17,
		/**
		 * The `Object` symbol kind.
		 */
		Object = 18,
		/**
		 * The `Key` symbol kind.
		 */
		Key = 19,
		/**
		 * The `Null` symbol kind.
		 */
		Null = 20,
		/**
		 * The `EnumMember` symbol kind.
		 */
		EnumMember = 21,
		/**
		 * The `Struct` symbol kind.
		 */
		Struct = 22,
		/**
		 * The `Event` symbol kind.
		 */
		Event = 23,
		/**
		 * The `Operator` symbol kind.
		 */
		Operator = 24,
		/**
		 * The `TypeParameter` symbol kind.
		 */
		TypeParameter = 25
	}

	/**
	 * Symbol tags are extra annotations that tweak the rendering of a symbol.
	 */
	export enum SymbolTag {

		/**
		 * Render a symbol as obsolete, usually using a strike-out.
		 */
		Deprecated = 1
	}

	/**
	 * Represents information about programming constructs like variables, classes,
	 * interfaces etc.
	 */
	export class SymbolInformation {

		/**
		 * The name of this symbol.
		 */
		name: string;

		/**
		 * The name of the symbol containing this symbol.
		 */
		containerName: string;

		/**
		 * The kind of this symbol.
		 */
		kind: SymbolKind;

		/**
		 * Tags for this symbol.
		 */
		tags?: readonly SymbolTag[];

		/**
		 * The location of this symbol.
		 */
		location: Location;

		/**
		 * Creates a new symbol information object.
		 *
		 * @param name The name of the symbol.
		 * @param kind The kind of the symbol.
		 * @param containerName The name of the symbol containing the symbol.
		 * @param location The location of the symbol.
		 */
		constructor(name: string, kind: SymbolKind, containerName: string, location: Location);

		/**
		 * Creates a new symbol information object.
		 *
		 * @deprecated Please use the constructor taking a {@link Location} object.
		 *
		 * @param name The name of the symbol.
		 * @param kind The kind of the symbol.
		 * @param range The range of the location of the symbol.
		 * @param uri The resource of the location of symbol, defaults to the current document.
		 * @param containerName The name of the symbol containing the symbol.
		 */
		constructor(name: string, kind: SymbolKind, range: Range, uri?: Uri, containerName?: string);
	}

	/**
	 * Represents programming constructs like variables, classes, interfaces etc. that appear in a document. Document
	 * symbols can be hierarchical and they have two ranges: one that encloses its definition and one that points to
	 * its most interesting range, e.g. the range of an identifier.
	 */
	export class DocumentSymbol {

		/**
		 * The name of this symbol.
		 */
		name: string;

		/**
		 * More detail for this symbol, e.g. the signature of a function.
		 */
		detail: string;

		/**
		 * The kind of this symbol.
		 */
		kind: SymbolKind;

		/**
		 * Tags for this symbol.
		 */
		tags?: readonly SymbolTag[];

		/**
		 * The range enclosing this symbol not including leading/trailing whitespace but everything else, e.g. comments and code.
		 */
		range: Range;

		/**
		 * The range that should be selected and reveal when this symbol is being picked, e.g. the name of a function.
		 * Must be contained by the {@linkcode DocumentSymbol.range range}.
		 */
		selectionRange: Range;

		/**
		 * Children of this symbol, e.g. properties of a class.
		 */
		children: DocumentSymbol[];

		/**
		 * Creates a new document symbol.
		 *
		 * @param name The name of the symbol.
		 * @param detail Details for the symbol.
		 * @param kind The kind of the symbol.
		 * @param range The full range of the symbol.
		 * @param selectionRange The range that should be reveal.
		 */
		constructor(name: string, detail: string, kind: SymbolKind, range: Range, selectionRange: Range);
	}

	/**
	 * The document symbol provider interface defines the contract between extensions and
	 * the [go to symbol](https://code.visualstudio.com/docs/editor/editingevolved#_go-to-symbol)-feature.
	 */
	export interface DocumentSymbolProvider {

		/**
		 * Provide symbol information for the given document.
		 *
		 * @param document The document in which the command was invoked.
		 * @param token A cancellation token.
		 * @returns An array of document highlights or a thenable that resolves to such. The lack of a result can be
		 * signaled by returning `undefined`, `null`, or an empty array.
		 */
		provideDocumentSymbols(document: TextDocument, token: CancellationToken): ProviderResult<SymbolInformation[] | DocumentSymbol[]>;
	}

	/**
	 * Metadata about a document symbol provider.
	 */
	export interface DocumentSymbolProviderMetadata {
		/**
		 * A human-readable string that is shown when multiple outlines trees show for one document.
		 */
		label?: string;
	}

	/**
	 * The workspace symbol provider interface defines the contract between extensions and
	 * the [symbol search](https://code.visualstudio.com/docs/editor/editingevolved#_open-symbol-by-name)-feature.
	 */
	export interface WorkspaceSymbolProvider<T extends SymbolInformation = SymbolInformation> {

		/**
		 * Project-wide search for a symbol matching the given query string.
		 *
		 * The `query`-parameter should be interpreted in a *relaxed way* as the editor will apply its own highlighting
		 * and scoring on the results. A good rule of thumb is to match case-insensitive and to simply check that the
		 * characters of *query* appear in their order in a candidate symbol. Don't use prefix, substring, or similar
		 * strict matching.
		 *
		 * To improve performance implementors can implement `resolveWorkspaceSymbol` and then provide symbols with partial
		 * {@link SymbolInformation.location location}-objects, without a `range` defined. The editor will then call
		 * `resolveWorkspaceSymbol` for selected symbols only, e.g. when opening a workspace symbol.
		 *
		 * @param query A query string, can be the empty string in which case all symbols should be returned.
		 * @param token A cancellation token.
		 * @returns An array of document highlights or a thenable that resolves to such. The lack of a result can be
		 * signaled by returning `undefined`, `null`, or an empty array.
		 */
		provideWorkspaceSymbols(query: string, token: CancellationToken): ProviderResult<T[]>;

		/**
		 * Given a symbol fill in its {@link SymbolInformation.location location}. This method is called whenever a symbol
		 * is selected in the UI. Providers can implement this method and return incomplete symbols from
		 * {@linkcode WorkspaceSymbolProvider.provideWorkspaceSymbols provideWorkspaceSymbols} which often helps to improve
		 * performance.
		 *
		 * @param symbol The symbol that is to be resolved. Guaranteed to be an instance of an object returned from an
		 * earlier call to `provideWorkspaceSymbols`.
		 * @param token A cancellation token.
		 * @returns The resolved symbol or a thenable that resolves to that. When no result is returned,
		 * the given `symbol` is used.
		 */
		resolveWorkspaceSymbol?(symbol: T, token: CancellationToken): ProviderResult<T>;
	}

	/**
	 * Value-object that contains additional information when
	 * requesting references.
	 */
	export interface ReferenceContext {

		/**
		 * Include the declaration of the current symbol.
		 */
		readonly includeDeclaration: boolean;
	}

	/**
	 * The reference provider interface defines the contract between extensions and
	 * the [find references](https://code.visualstudio.com/docs/editor/editingevolved#_peek)-feature.
	 */
	export interface ReferenceProvider {

		/**
		 * Provide a set of project-wide references for the given position and document.
		 *
		 * @param document The document in which the command was invoked.
		 * @param position The position at which the command was invoked.
		 * @param context Additional information about the references request.
		 * @param token A cancellation token.
		 *
		 * @returns An array of locations or a thenable that resolves to such. The lack of a result can be
		 * signaled by returning `undefined`, `null`, or an empty array.
		 */
		provideReferences(document: TextDocument, position: Position, context: ReferenceContext, token: CancellationToken): ProviderResult<Location[]>;
	}

	/**
	 * A text edit represents edits that should be applied
	 * to a document.
	 */
	export class TextEdit {

		/**
		 * Utility to create a replace edit.
		 *
		 * @param range A range.
		 * @param newText A string.
		 * @returns A new text edit object.
		 */
		static replace(range: Range, newText: string): TextEdit;

		/**
		 * Utility to create an insert edit.
		 *
		 * @param position A position, will become an empty range.
		 * @param newText A string.
		 * @returns A new text edit object.
		 */
		static insert(position: Position, newText: string): TextEdit;

		/**
		 * Utility to create a delete edit.
		 *
		 * @param range A range.
		 * @returns A new text edit object.
		 */
		static delete(range: Range): TextEdit;

		/**
		 * Utility to create an eol-edit.
		 *
		 * @param eol An eol-sequence
		 * @returns A new text edit object.
		 */
		static setEndOfLine(eol: EndOfLine): TextEdit;

		/**
		 * The range this edit applies to.
		 */
		range: Range;

		/**
		 * The string this edit will insert.
		 */
		newText: string;

		/**
		 * The eol-sequence used in the document.
		 *
		 * *Note* that the eol-sequence will be applied to the
		 * whole document.
		 */
		newEol?: EndOfLine;

		/**
		 * Create a new TextEdit.
		 *
		 * @param range A range.
		 * @param newText A string.
		 */
		constructor(range: Range, newText: string);
	}

	/**
	 * A snippet edit represents an interactive edit that is performed by
	 * the editor.
	 *
	 * *Note* that a snippet edit can always be performed as a normal {@link TextEdit text edit}.
	 * This will happen when no matching editor is open or when a {@link WorkspaceEdit workspace edit}
	 * contains snippet edits for multiple files. In that case only those that match the active editor
	 * will be performed as snippet edits and the others as normal text edits.
	 */
	export class SnippetTextEdit {

		/**
		 * Utility to create a replace snippet edit.
		 *
		 * @param range A range.
		 * @param snippet A snippet string.
		 * @returns A new snippet edit object.
		 */
		static replace(range: Range, snippet: SnippetString): SnippetTextEdit;

		/**
		 * Utility to create an insert snippet edit.
		 *
		 * @param position A position, will become an empty range.
		 * @param snippet A snippet string.
		 * @returns A new snippet edit object.
		 */
		static insert(position: Position, snippet: SnippetString): SnippetTextEdit;

		/**
		 * The range this edit applies to.
		 */
		range: Range;

		/**
		 * The {@link SnippetString snippet} this edit will perform.
		 */
		snippet: SnippetString;

		/**
		 * Whether the snippet edit should be applied with existing whitespace preserved.
		 */
		keepWhitespace?: boolean;

		/**
		 * Create a new snippet edit.
		 *
		 * @param range A range.
		 * @param snippet A snippet string.
		 */
		constructor(range: Range, snippet: SnippetString);
	}

	/**
	 * A notebook edit represents edits that should be applied to the contents of a notebook.
	 */
	export class NotebookEdit {

		/**
		 * Utility to create a edit that replaces cells in a notebook.
		 *
		 * @param range The range of cells to replace
		 * @param newCells The new notebook cells.
		 */
		static replaceCells(range: NotebookRange, newCells: NotebookCellData[]): NotebookEdit;

		/**
		 * Utility to create an edit that replaces cells in a notebook.
		 *
		 * @param index The index to insert cells at.
		 * @param newCells The new notebook cells.
		 */
		static insertCells(index: number, newCells: NotebookCellData[]): NotebookEdit;

		/**
		 * Utility to create an edit that deletes cells in a notebook.
		 *
		 * @param range The range of cells to delete.
		 */
		static deleteCells(range: NotebookRange): NotebookEdit;

		/**
		 * Utility to create an edit that update a cell's metadata.
		 *
		 * @param index The index of the cell to update.
		 * @param newCellMetadata The new metadata for the cell.
		 */
		static updateCellMetadata(index: number, newCellMetadata: { [key: string]: any }): NotebookEdit;

		/**
		 * Utility to create an edit that updates the notebook's metadata.
		 *
		 * @param newNotebookMetadata The new metadata for the notebook.
		 */
		static updateNotebookMetadata(newNotebookMetadata: { [key: string]: any }): NotebookEdit;

		/**
		 * Range of the cells being edited. May be empty.
		 */
		range: NotebookRange;

		/**
		 * New cells being inserted. May be empty.
		 */
		newCells: NotebookCellData[];

		/**
		 * Optional new metadata for the cells.
		 */
		newCellMetadata?: { [key: string]: any };

		/**
		 * Optional new metadata for the notebook.
		 */
		newNotebookMetadata?: { [key: string]: any };

		/**
		 * Create a new notebook edit.
		 *
		 * @param range A notebook range.
		 * @param newCells An array of new cell data.
		 */
		constructor(range: NotebookRange, newCells: NotebookCellData[]);
	}

	/**
	 * Additional data for entries of a workspace edit. Supports to label entries and marks entries
	 * as needing confirmation by the user. The editor groups edits with equal labels into tree nodes,
	 * for instance all edits labelled with "Changes in Strings" would be a tree node.
	 */
	export interface WorkspaceEditEntryMetadata {

		/**
		 * A flag which indicates that user confirmation is needed.
		 */
		needsConfirmation: boolean;

		/**
		 * A human-readable string which is rendered prominent.
		 */
		label: string;

		/**
		 * A human-readable string which is rendered less prominent on the same line.
		 */
		description?: string;

		/**
		 * The icon path or {@link ThemeIcon} for the edit.
		 */
		iconPath?: IconPath;
	}

	/**
	 * Additional data about a workspace edit.
	 */
	export interface WorkspaceEditMetadata {
		/**
		 * Signal to the editor that this edit is a refactoring.
		 */
		isRefactoring?: boolean;
	}

	/**
	 * A workspace edit is a collection of textual and files changes for
	 * multiple resources and documents.
	 *
	 * Use the {@link workspace.applyEdit applyEdit}-function to apply a workspace edit.
	 */
	export class WorkspaceEdit {

		/**
		 * The number of affected resources of textual or resource changes.
		 */
		readonly size: number;

		/**
		 * Replace the given range with given text for the given resource.
		 *
		 * @param uri A resource identifier.
		 * @param range A range.
		 * @param newText A string.
		 * @param metadata Optional metadata for the entry.
		 */
		replace(uri: Uri, range: Range, newText: string, metadata?: WorkspaceEditEntryMetadata): void;

		/**
		 * Insert the given text at the given position.
		 *
		 * @param uri A resource identifier.
		 * @param position A position.
		 * @param newText A string.
		 * @param metadata Optional metadata for the entry.
		 */
		insert(uri: Uri, position: Position, newText: string, metadata?: WorkspaceEditEntryMetadata): void;

		/**
		 * Delete the text at the given range.
		 *
		 * @param uri A resource identifier.
		 * @param range A range.
		 * @param metadata Optional metadata for the entry.
		 */
		delete(uri: Uri, range: Range, metadata?: WorkspaceEditEntryMetadata): void;

		/**
		 * Check if a text edit for a resource exists.
		 *
		 * @param uri A resource identifier.
		 * @returns `true` if the given resource will be touched by this edit.
		 */
		has(uri: Uri): boolean;

		/**
		 * Set (and replace) text edits or snippet edits for a resource.
		 *
		 * @param uri A resource identifier.
		 * @param edits An array of edits.
		 */
		set(uri: Uri, edits: ReadonlyArray<TextEdit | SnippetTextEdit>): void;

		/**
		 * Set (and replace) text edits or snippet edits with metadata for a resource.
		 *
		 * @param uri A resource identifier.
		 * @param edits An array of edits.
		 */
		set(uri: Uri, edits: ReadonlyArray<[TextEdit | SnippetTextEdit, WorkspaceEditEntryMetadata | undefined]>): void;

		/**
		 * Set (and replace) notebook edits for a resource.
		 *
		 * @param uri A resource identifier.
		 * @param edits An array of edits.
		 */
		set(uri: Uri, edits: readonly NotebookEdit[]): void;

		/**
		 * Set (and replace) notebook edits with metadata for a resource.
		 *
		 * @param uri A resource identifier.
		 * @param edits An array of edits.
		 */
		set(uri: Uri, edits: ReadonlyArray<[NotebookEdit, WorkspaceEditEntryMetadata | undefined]>): void;

		/**
		 * Get the text edits for a resource.
		 *
		 * @param uri A resource identifier.
		 * @returns An array of text edits.
		 */
		get(uri: Uri): TextEdit[];

		/**
		 * Create a regular file.
		 *
		 * @param uri Uri of the new file.
		 * @param options Defines if an existing file should be overwritten or be
		 * ignored. When `overwrite` and `ignoreIfExists` are both set `overwrite` wins.
		 * When both are unset and when the file already exists then the edit cannot
		 * be applied successfully. The `content`-property allows to set the initial contents
		 * the file is being created with.
		 * @param metadata Optional metadata for the entry.
		 */
		createFile(uri: Uri, options?: {
			/**
			 * Overwrite existing file. Overwrite wins over `ignoreIfExists`
			 */
			readonly overwrite?: boolean;
			/**
			 * Do nothing if a file with `uri` exists already.
			 */
			readonly ignoreIfExists?: boolean;
			/**
			 * The initial contents of the new file.
			 *
			 * If creating a file from a {@link DocumentDropEditProvider drop operation}, you can
			 * pass in a {@link DataTransferFile} to improve performance by avoiding extra data copying.
			 */
			readonly contents?: Uint8Array | DataTransferFile;
		}, metadata?: WorkspaceEditEntryMetadata): void;

		/**
		 * Delete a file or folder.
		 *
		 * @param uri The uri of the file that is to be deleted.
		 * @param metadata Optional metadata for the entry.
		 */
		deleteFile(uri: Uri, options?: {
			/**
			 * Delete the content recursively if a folder is denoted.
			 */
			readonly recursive?: boolean;
			/**
			 * Do nothing if a file with `uri` exists already.
			 */
			readonly ignoreIfNotExists?: boolean;
		}, metadata?: WorkspaceEditEntryMetadata): void;

		/**
		 * Rename a file or folder.
		 *
		 * @param oldUri The existing file.
		 * @param newUri The new location.
		 * @param options Defines if existing files should be overwritten or be
		 * ignored. When overwrite and ignoreIfExists are both set overwrite wins.
		 * @param metadata Optional metadata for the entry.
		 */
		renameFile(oldUri: Uri, newUri: Uri, options?: {
			/**
			 * Overwrite existing file. Overwrite wins over `ignoreIfExists`
			 */
			readonly overwrite?: boolean;
			/**
			 * Do nothing if a file with `uri` exists already.
			 */
			readonly ignoreIfExists?: boolean;
		}, metadata?: WorkspaceEditEntryMetadata): void;

		/**
		 * Get all text edits grouped by resource.
		 *
		 * @returns A shallow copy of `[Uri, TextEdit[]]`-tuples.
		 */
		entries(): [Uri, TextEdit[]][];
	}

	/**
	 * A snippet string is a template which allows to insert text
	 * and to control the editor cursor when insertion happens.
	 *
	 * A snippet can define tab stops and placeholders with `$1`, `$2`
	 * and `${3:foo}`. `$0` defines the final tab stop, it defaults to
	 * the end of the snippet. Variables are defined with `$name` and
	 * `${name:default value}`. Also see
	 * [the full snippet syntax](https://code.visualstudio.com/docs/editor/userdefinedsnippets#_create-your-own-snippets).
	 */
	export class SnippetString {

		/**
		 * The snippet string.
		 */
		value: string;

		/**
		 * Create a new snippet string.
		 *
		 * @param value A snippet string.
		 */
		constructor(value?: string);

		/**
		 * Builder-function that appends the given string to
		 * the {@linkcode SnippetString.value value} of this snippet string.
		 *
		 * @param string A value to append 'as given'. The string will be escaped.
		 * @returns This snippet string.
		 */
		appendText(string: string): SnippetString;

		/**
		 * Builder-function that appends a tabstop (`$1`, `$2` etc) to
		 * the {@linkcode SnippetString.value value} of this snippet string.
		 *
		 * @param number The number of this tabstop, defaults to an auto-increment
		 * value starting at 1.
		 * @returns This snippet string.
		 */
		appendTabstop(number?: number): SnippetString;

		/**
		 * Builder-function that appends a placeholder (`${1:value}`) to
		 * the {@linkcode SnippetString.value value} of this snippet string.
		 *
		 * @param value The value of this placeholder - either a string or a function
		 * with which a nested snippet can be created.
		 * @param number The number of this tabstop, defaults to an auto-increment
		 * value starting at 1.
		 * @returns This snippet string.
		 */
		appendPlaceholder(value: string | ((snippet: SnippetString) => any), number?: number): SnippetString;

		/**
		 * Builder-function that appends a choice (`${1|a,b,c|}`) to
		 * the {@linkcode SnippetString.value value} of this snippet string.
		 *
		 * @param values The values for choices - the array of strings
		 * @param number The number of this tabstop, defaults to an auto-increment
		 * value starting at 1.
		 * @returns This snippet string.
		 */
		appendChoice(values: readonly string[], number?: number): SnippetString;

		/**
		 * Builder-function that appends a variable (`${VAR}`) to
		 * the {@linkcode SnippetString.value value} of this snippet string.
		 *
		 * @param name The name of the variable - excluding the `$`.
		 * @param defaultValue The default value which is used when the variable name cannot
		 * be resolved - either a string or a function with which a nested snippet can be created.
		 * @returns This snippet string.
		 */
		appendVariable(name: string, defaultValue: string | ((snippet: SnippetString) => any)): SnippetString;
	}

	/**
	 * The rename provider interface defines the contract between extensions and
	 * the [rename](https://code.visualstudio.com/docs/editor/editingevolved#_rename-symbol)-feature.
	 */
	export interface RenameProvider {

		/**
		 * Provide an edit that describes changes that have to be made to one
		 * or many resources to rename a symbol to a different name.
		 *
		 * @param document The document in which the command was invoked.
		 * @param position The position at which the command was invoked.
		 * @param newName The new name of the symbol. If the given name is not valid, the provider must return a rejected promise.
		 * @param token A cancellation token.
		 * @returns A workspace edit or a thenable that resolves to such. The lack of a result can be
		 * signaled by returning `undefined` or `null`.
		 */
		provideRenameEdits(document: TextDocument, position: Position, newName: string, token: CancellationToken): ProviderResult<WorkspaceEdit>;

		/**
		 * Optional function for resolving and validating a position *before* running rename. The result can
		 * be a range or a range and a placeholder text. The placeholder text should be the identifier of the symbol
		 * which is being renamed - when omitted the text in the returned range is used.
		 *
		 * *Note:* This function should throw an error or return a rejected thenable when the provided location
		 * doesn't allow for a rename.
		 *
		 * @param document The document in which rename will be invoked.
		 * @param position The position at which rename will be invoked.
		 * @param token A cancellation token.
		 * @returns The range or range and placeholder text of the identifier that is to be renamed. The lack of a result can signaled by returning `undefined` or `null`.
		 */
		prepareRename?(document: TextDocument, position: Position, token: CancellationToken): ProviderResult<Range | {
			/**
			 * The range of the identifier that can be renamed.
			 */
			range: Range;
			/**
			 * The placeholder of the editors rename input box.
			 */
			placeholder: string;
		}>;
	}

	/**
	 * A semantic tokens legend contains the needed information to decipher
	 * the integer encoded representation of semantic tokens.
	 */
	export class SemanticTokensLegend {
		/**
		 * The possible token types.
		 */
		readonly tokenTypes: string[];
		/**
		 * The possible token modifiers.
		 */
		readonly tokenModifiers: string[];

		/**
		 * Creates a semantic tokens legend.
		 *
		 * @param tokenTypes An array of token types.
		 * @param tokenModifiers An array of token modifiers.
		 */
		constructor(tokenTypes: string[], tokenModifiers?: string[]);
	}

	/**
	 * A semantic tokens builder can help with creating a `SemanticTokens` instance
	 * which contains delta encoded semantic tokens.
	 */
	export class SemanticTokensBuilder {

		/**
		 * Creates a semantic tokens builder.
		 *
		 * @param legend A semantic tokens legend.
		 */
		constructor(legend?: SemanticTokensLegend);

		/**
		 * Add another token.
		 *
		 * @param line The token start line number (absolute value).
		 * @param char The token start character (absolute value).
		 * @param length The token length in characters.
		 * @param tokenType The encoded token type.
		 * @param tokenModifiers The encoded token modifiers.
		 */
		push(line: number, char: number, length: number, tokenType: number, tokenModifiers?: number): void;

		/**
		 * Add another token. Use only when providing a legend.
		 *
		 * @param range The range of the token. Must be single-line.
		 * @param tokenType The token type.
		 * @param tokenModifiers The token modifiers.
		 */
		push(range: Range, tokenType: string, tokenModifiers?: readonly string[]): void;

		/**
		 * Finish and create a `SemanticTokens` instance.
		 */
		build(resultId?: string): SemanticTokens;
	}

	/**
	 * Represents semantic tokens, either in a range or in an entire document.
	 * @see {@link DocumentSemanticTokensProvider.provideDocumentSemanticTokens provideDocumentSemanticTokens} for an explanation of the format.
	 * @see {@link SemanticTokensBuilder} for a helper to create an instance.
	 */
	export class SemanticTokens {
		/**
		 * The result id of the tokens.
		 *
		 * This is the id that will be passed to `DocumentSemanticTokensProvider.provideDocumentSemanticTokensEdits` (if implemented).
		 */
		readonly resultId: string | undefined;
		/**
		 * The actual tokens data.
		 * @see {@link DocumentSemanticTokensProvider.provideDocumentSemanticTokens provideDocumentSemanticTokens} for an explanation of the format.
		 */
		readonly data: Uint32Array;

		/**
		 * Create new semantic tokens.
		 *
		 * @param data Token data.
		 * @param resultId Result identifier.
		 */
		constructor(data: Uint32Array, resultId?: string);
	}

	/**
	 * Represents edits to semantic tokens.
	 * @see {@link DocumentSemanticTokensProvider.provideDocumentSemanticTokensEdits provideDocumentSemanticTokensEdits} for an explanation of the format.
	 */
	export class SemanticTokensEdits {
		/**
		 * The result id of the tokens.
		 *
		 * This is the id that will be passed to `DocumentSemanticTokensProvider.provideDocumentSemanticTokensEdits` (if implemented).
		 */
		readonly resultId: string | undefined;
		/**
		 * The edits to the tokens data.
		 * All edits refer to the initial data state.
		 */
		readonly edits: SemanticTokensEdit[];

		/**
		 * Create new semantic tokens edits.
		 *
		 * @param edits An array of semantic token edits
		 * @param resultId Result identifier.
		 */
		constructor(edits: SemanticTokensEdit[], resultId?: string);
	}

	/**
	 * Represents an edit to semantic tokens.
	 * @see {@link DocumentSemanticTokensProvider.provideDocumentSemanticTokensEdits provideDocumentSemanticTokensEdits} for an explanation of the format.
	 */
	export class SemanticTokensEdit {
		/**
		 * The start offset of the edit.
		 */
		readonly start: number;
		/**
		 * The count of elements to remove.
		 */
		readonly deleteCount: number;
		/**
		 * The elements to insert.
		 */
		readonly data: Uint32Array | undefined;

		/**
		 * Create a semantic token edit.
		 *
		 * @param start Start offset
		 * @param deleteCount Number of elements to remove.
		 * @param data Elements to insert
		 */
		constructor(start: number, deleteCount: number, data?: Uint32Array);
	}

	/**
	 * The document semantic tokens provider interface defines the contract between extensions and
	 * semantic tokens.
	 */
	export interface DocumentSemanticTokensProvider {
		/**
		 * An optional event to signal that the semantic tokens from this provider have changed.
		 */
		onDidChangeSemanticTokens?: Event<void>;

		/**
		 * Tokens in a file are represented as an array of integers. The position of each token is expressed relative to
		 * the token before it, because most tokens remain stable relative to each other when edits are made in a file.
		 *
		 * ---
		 * In short, each token takes 5 integers to represent, so a specific token `i` in the file consists of the following array indices:
		 *  - at index `5*i`   - `deltaLine`: token line number, relative to the previous token
		 *  - at index `5*i+1` - `deltaStart`: token start character, relative to the previous token (relative to 0 or the previous token's start if they are on the same line)
		 *  - at index `5*i+2` - `length`: the length of the token. A token cannot be multiline.
		 *  - at index `5*i+3` - `tokenType`: will be looked up in `SemanticTokensLegend.tokenTypes`. We currently ask that `tokenType` < 65536.
		 *  - at index `5*i+4` - `tokenModifiers`: each set bit will be looked up in `SemanticTokensLegend.tokenModifiers`
		 *
		 * ---
		 * ### How to encode tokens
		 *
		 * Here is an example for encoding a file with 3 tokens in a uint32 array:
		 * ```
		 *    { line: 2, startChar:  5, length: 3, tokenType: "property",  tokenModifiers: ["private", "static"] },
		 *    { line: 2, startChar: 10, length: 4, tokenType: "type",      tokenModifiers: [] },
		 *    { line: 5, startChar:  2, length: 7, tokenType: "class",     tokenModifiers: [] }
		 * ```
		 *
		 * 1. First of all, a legend must be devised. This legend must be provided up-front and capture all possible token types.
		 * For this example, we will choose the following legend which must be passed in when registering the provider:
		 * ```
		 *    tokenTypes: ['property', 'type', 'class'],
		 *    tokenModifiers: ['private', 'static']
		 * ```
		 *
		 * 2. The first transformation step is to encode `tokenType` and `tokenModifiers` as integers using the legend. Token types are looked
		 * up by index, so a `tokenType` value of `1` means `tokenTypes[1]`. Multiple token modifiers can be set by using bit flags,
		 * so a `tokenModifier` value of `3` is first viewed as binary `0b00000011`, which means `[tokenModifiers[0], tokenModifiers[1]]` because
		 * bits 0 and 1 are set. Using this legend, the tokens now are:
		 * ```
		 *    { line: 2, startChar:  5, length: 3, tokenType: 0, tokenModifiers: 3 },
		 *    { line: 2, startChar: 10, length: 4, tokenType: 1, tokenModifiers: 0 },
		 *    { line: 5, startChar:  2, length: 7, tokenType: 2, tokenModifiers: 0 }
		 * ```
		 *
		 * 3. The next step is to represent each token relative to the previous token in the file. In this case, the second token
		 * is on the same line as the first token, so the `startChar` of the second token is made relative to the `startChar`
		 * of the first token, so it will be `10 - 5`. The third token is on a different line than the second token, so the
		 * `startChar` of the third token will not be altered:
		 * ```
		 *    { deltaLine: 2, deltaStartChar: 5, length: 3, tokenType: 0, tokenModifiers: 3 },
		 *    { deltaLine: 0, deltaStartChar: 5, length: 4, tokenType: 1, tokenModifiers: 0 },
		 *    { deltaLine: 3, deltaStartChar: 2, length: 7, tokenType: 2, tokenModifiers: 0 }
		 * ```
		 *
		 * 4. Finally, the last step is to inline each of the 5 fields for a token in a single array, which is a memory friendly representation:
		 * ```
		 *    // 1st token,  2nd token,  3rd token
		 *    [  2,5,3,0,3,  0,5,4,1,0,  3,2,7,2,0 ]
		 * ```
		 *
		 * @see {@link SemanticTokensBuilder} for a helper to encode tokens as integers.
		 * *NOTE*: When doing edits, it is possible that multiple edits occur until the editor decides to invoke the semantic tokens provider.
		 * *NOTE*: If the provider cannot temporarily compute semantic tokens, it can indicate this by throwing an error with the message 'Busy'.
		 */
		provideDocumentSemanticTokens(document: TextDocument, token: CancellationToken): ProviderResult<SemanticTokens>;

		/**
		 * Instead of always returning all the tokens in a file, it is possible for a `DocumentSemanticTokensProvider` to implement
		 * this method (`provideDocumentSemanticTokensEdits`) and then return incremental updates to the previously provided semantic tokens.
		 *
		 * ---
		 * ### How tokens change when the document changes
		 *
		 * Suppose that `provideDocumentSemanticTokens` has previously returned the following semantic tokens:
		 * ```
		 *    // 1st token,  2nd token,  3rd token
		 *    [  2,5,3,0,3,  0,5,4,1,0,  3,2,7,2,0 ]
		 * ```
		 *
		 * Also suppose that after some edits, the new semantic tokens in a file are:
		 * ```
		 *    // 1st token,  2nd token,  3rd token
		 *    [  3,5,3,0,3,  0,5,4,1,0,  3,2,7,2,0 ]
		 * ```
		 * It is possible to express these new tokens in terms of an edit applied to the previous tokens:
		 * ```
		 *    [  2,5,3,0,3,  0,5,4,1,0,  3,2,7,2,0 ] // old tokens
		 *    [  3,5,3,0,3,  0,5,4,1,0,  3,2,7,2,0 ] // new tokens
		 *
		 *    edit: { start:  0, deleteCount: 1, data: [3] } // replace integer at offset 0 with 3
		 * ```
		 *
		 * *NOTE*: If the provider cannot compute `SemanticTokensEdits`, it can "give up" and return all the tokens in the document again.
		 * *NOTE*: All edits in `SemanticTokensEdits` contain indices in the old integers array, so they all refer to the previous result state.
		 */
		provideDocumentSemanticTokensEdits?(document: TextDocument, previousResultId: string, token: CancellationToken): ProviderResult<SemanticTokens | SemanticTokensEdits>;
	}

	/**
	 * The document range semantic tokens provider interface defines the contract between extensions and
	 * semantic tokens.
	 */
	export interface DocumentRangeSemanticTokensProvider {
		/**
		 * @see {@link DocumentSemanticTokensProvider.provideDocumentSemanticTokens provideDocumentSemanticTokens}.
		 */
		provideDocumentRangeSemanticTokens(document: TextDocument, range: Range, token: CancellationToken): ProviderResult<SemanticTokens>;
	}

	/**
	 * Value-object describing what options formatting should use.
	 */
	export interface FormattingOptions {

		/**
		 * Size of a tab in spaces.
		 */
		tabSize: number;

		/**
		 * Prefer spaces over tabs.
		 */
		insertSpaces: boolean;

		/**
		 * Signature for further properties.
		 */
		[key: string]: boolean | number | string;
	}

	/**
	 * The document formatting provider interface defines the contract between extensions and
	 * the formatting-feature.
	 */
	export interface DocumentFormattingEditProvider {

		/**
		 * Provide formatting edits for a whole document.
		 *
		 * @param document The document in which the command was invoked.
		 * @param options Options controlling formatting.
		 * @param token A cancellation token.
		 * @returns A set of text edits or a thenable that resolves to such. The lack of a result can be
		 * signaled by returning `undefined`, `null`, or an empty array.
		 */
		provideDocumentFormattingEdits(document: TextDocument, options: FormattingOptions, token: CancellationToken): ProviderResult<TextEdit[]>;
	}

	/**
	 * The document formatting provider interface defines the contract between extensions and
	 * the formatting-feature.
	 */
	export interface DocumentRangeFormattingEditProvider {

		/**
		 * Provide formatting edits for a range in a document.
		 *
		 * The given range is a hint and providers can decide to format a smaller
		 * or larger range. Often this is done by adjusting the start and end
		 * of the range to full syntax nodes.
		 *
		 * @param document The document in which the command was invoked.
		 * @param range The range which should be formatted.
		 * @param options Options controlling formatting.
		 * @param token A cancellation token.
		 * @returns A set of text edits or a thenable that resolves to such. The lack of a result can be
		 * signaled by returning `undefined`, `null`, or an empty array.
		 */
		provideDocumentRangeFormattingEdits(document: TextDocument, range: Range, options: FormattingOptions, token: CancellationToken): ProviderResult<TextEdit[]>;


		/**
		 * Provide formatting edits for multiple ranges in a document.
		 *
		 * This function is optional but allows a formatter to perform faster when formatting only modified ranges or when
		 * formatting a large number of selections.
		 *
		 * The given ranges are hints and providers can decide to format a smaller
		 * or larger range. Often this is done by adjusting the start and end
		 * of the range to full syntax nodes.
		 *
		 * @param document The document in which the command was invoked.
		 * @param ranges The ranges which should be formatted.
		 * @param options Options controlling formatting.
		 * @param token A cancellation token.
		 * @returns A set of text edits or a thenable that resolves to such. The lack of a result can be
		 * signaled by returning `undefined`, `null`, or an empty array.
		 */
		provideDocumentRangesFormattingEdits?(document: TextDocument, ranges: Range[], options: FormattingOptions, token: CancellationToken): ProviderResult<TextEdit[]>;
	}

	/**
	 * The document formatting provider interface defines the contract between extensions and
	 * the formatting-feature.
	 */
	export interface OnTypeFormattingEditProvider {

		/**
		 * Provide formatting edits after a character has been typed.
		 *
		 * The given position and character should hint to the provider
		 * what range the position to expand to, like find the matching `{`
		 * when `}` has been entered.
		 *
		 * @param document The document in which the command was invoked.
		 * @param position The position at which the command was invoked.
		 * @param ch The character that has been typed.
		 * @param options Options controlling formatting.
		 * @param token A cancellation token.
		 * @returns A set of text edits or a thenable that resolves to such. The lack of a result can be
		 * signaled by returning `undefined`, `null`, or an empty array.
		 */
		provideOnTypeFormattingEdits(document: TextDocument, position: Position, ch: string, options: FormattingOptions, token: CancellationToken): ProviderResult<TextEdit[]>;
	}

	/**
	 * Represents a parameter of a callable-signature. A parameter can
	 * have a label and a doc-comment.
	 */
	export class ParameterInformation {

		/**
		 * The label of this signature.
		 *
		 * Either a string or inclusive start and exclusive end offsets within its containing
		 * {@link SignatureInformation.label signature label}. *Note*: A label of type string must be
		 * a substring of its containing signature information's {@link SignatureInformation.label label}.
		 */
		label: string | [number, number];

		/**
		 * The human-readable doc-comment of this signature. Will be shown
		 * in the UI but can be omitted.
		 */
		documentation?: string | MarkdownString;

		/**
		 * Creates a new parameter information object.
		 *
		 * @param label A label string or inclusive start and exclusive end offsets within its containing signature label.
		 * @param documentation A doc string.
		 */
		constructor(label: string | [number, number], documentation?: string | MarkdownString);
	}

	/**
	 * Represents the signature of something callable. A signature
	 * can have a label, like a function-name, a doc-comment, and
	 * a set of parameters.
	 */
	export class SignatureInformation {

		/**
		 * The label of this signature. Will be shown in
		 * the UI.
		 */
		label: string;

		/**
		 * The human-readable doc-comment of this signature. Will be shown
		 * in the UI but can be omitted.
		 */
		documentation?: string | MarkdownString;

		/**
		 * The parameters of this signature.
		 */
		parameters: ParameterInformation[];

		/**
		 * The index of the active parameter.
		 *
		 * If provided, this is used in place of {@linkcode SignatureHelp.activeParameter}.
		 */
		activeParameter?: number;

		/**
		 * Creates a new signature information object.
		 *
		 * @param label A label string.
		 * @param documentation A doc string.
		 */
		constructor(label: string, documentation?: string | MarkdownString);
	}

	/**
	 * Signature help represents the signature of something
	 * callable. There can be multiple signatures but only one
	 * active and only one active parameter.
	 */
	export class SignatureHelp {

		/**
		 * One or more signatures.
		 */
		signatures: SignatureInformation[];

		/**
		 * The active signature.
		 */
		activeSignature: number;

		/**
		 * The active parameter of the active signature.
		 */
		activeParameter: number;
	}

	/**
	 * How a {@linkcode SignatureHelpProvider} was triggered.
	 */
	export enum SignatureHelpTriggerKind {
		/**
		 * Signature help was invoked manually by the user or by a command.
		 */
		Invoke = 1,

		/**
		 * Signature help was triggered by a trigger character.
		 */
		TriggerCharacter = 2,

		/**
		 * Signature help was triggered by the cursor moving or by the document content changing.
		 */
		ContentChange = 3,
	}

	/**
	 * Additional information about the context in which a
	 * {@linkcode SignatureHelpProvider.provideSignatureHelp SignatureHelpProvider} was triggered.
	 */
	export interface SignatureHelpContext {
		/**
		 * Action that caused signature help to be triggered.
		 */
		readonly triggerKind: SignatureHelpTriggerKind;

		/**
		 * Character that caused signature help to be triggered.
		 *
		 * This is `undefined` when signature help is not triggered by typing, such as when manually invoking
		 * signature help or when moving the cursor.
		 */
		readonly triggerCharacter: string | undefined;

		/**
		 * `true` if signature help was already showing when it was triggered.
		 *
		 * Retriggers occur when the signature help is already active and can be caused by actions such as
		 * typing a trigger character, a cursor move, or document content changes.
		 */
		readonly isRetrigger: boolean;

		/**
		 * The currently active {@linkcode SignatureHelp}.
		 *
		 * The `activeSignatureHelp` has its {@linkcode SignatureHelp.activeSignature activeSignature} field updated based on
		 * the user arrowing through available signatures.
		 */
		readonly activeSignatureHelp: SignatureHelp | undefined;
	}

	/**
	 * The signature help provider interface defines the contract between extensions and
	 * the [parameter hints](https://code.visualstudio.com/docs/editor/intellisense)-feature.
	 */
	export interface SignatureHelpProvider {

		/**
		 * Provide help for the signature at the given position and document.
		 *
		 * @param document The document in which the command was invoked.
		 * @param position The position at which the command was invoked.
		 * @param token A cancellation token.
		 * @param context Information about how signature help was triggered.
		 *
		 * @returns Signature help or a thenable that resolves to such. The lack of a result can be
		 * signaled by returning `undefined` or `null`.
		 */
		provideSignatureHelp(document: TextDocument, position: Position, token: CancellationToken, context: SignatureHelpContext): ProviderResult<SignatureHelp>;
	}

	/**
	 * Metadata about a registered {@linkcode SignatureHelpProvider}.
	 */
	export interface SignatureHelpProviderMetadata {
		/**
		 * List of characters that trigger signature help.
		 */
		readonly triggerCharacters: readonly string[];

		/**
		 * List of characters that re-trigger signature help.
		 *
		 * These trigger characters are only active when signature help is already showing. All trigger characters
		 * are also counted as re-trigger characters.
		 */
		readonly retriggerCharacters: readonly string[];
	}

	/**
	 * A structured label for a {@link CompletionItem completion item}.
	 */
	export interface CompletionItemLabel {

		/**
		 * The label of this completion item.
		 *
		 * By default this is also the text that is inserted when this completion is selected.
		 */
		label: string;

		/**
		 * An optional string which is rendered less prominently directly after {@link CompletionItemLabel.label label},
		 * without any spacing. Should be used for function signatures or type annotations.
		 */
		detail?: string;

		/**
		 * An optional string which is rendered less prominently after {@link CompletionItemLabel.detail}. Should be used
		 * for fully qualified names or file path.
		 */
		description?: string;
	}

	/**
	 * Completion item kinds.
	 */
	export enum CompletionItemKind {
		/**
		 * The `Text` completion item kind.
		 */
		Text = 0,
		/**
		 * The `Method` completion item kind.
		 */
		Method = 1,
		/**
		 * The `Function` completion item kind.
		 */
		Function = 2,
		/**
		 * The `Constructor` completion item kind.
		 */
		Constructor = 3,
		/**
		 * The `Field` completion item kind.
		 */
		Field = 4,
		/**
		 * The `Variable` completion item kind.
		 */
		Variable = 5,
		/**
		 * The `Class` completion item kind.
		 */
		Class = 6,
		/**
		 * The `Interface` completion item kind.
		 */
		Interface = 7,
		/**
		 * The `Module` completion item kind.
		 */
		Module = 8,
		/**
		 * The `Property` completion item kind.
		 */
		Property = 9,
		/**
		 * The `Unit` completion item kind.
		 */
		Unit = 10,
		/**
		 * The `Value` completion item kind.
		 */
		Value = 11,
		/**
		 * The `Enum` completion item kind.
		 */
		Enum = 12,
		/**
		 * The `Keyword` completion item kind.
		 */
		Keyword = 13,
		/**
		 * The `Snippet` completion item kind.
		 */
		Snippet = 14,
		/**
		 * The `Color` completion item kind.
		 */
		Color = 15,
		/**
		 * The `Reference` completion item kind.
		 */
		Reference = 17,
		/**
		 * The `File` completion item kind.
		 */
		File = 16,
		/**
		 * The `Folder` completion item kind.
		 */
		Folder = 18,
		/**
		 * The `EnumMember` completion item kind.
		 */
		EnumMember = 19,
		/**
		 * The `Constant` completion item kind.
		 */
		Constant = 20,
		/**
		 * The `Struct` completion item kind.
		 */
		Struct = 21,
		/**
		 * The `Event` completion item kind.
		 */
		Event = 22,
		/**
		 * The `Operator` completion item kind.
		 */
		Operator = 23,
		/**
		 * The `TypeParameter` completion item kind.
		 */
		TypeParameter = 24,
		/**
		 * The `User` completion item kind.
		 */
		User = 25,
		/**
		 * The `Issue` completion item kind.
		 */
		Issue = 26,
	}

	/**
	 * Completion item tags are extra annotations that tweak the rendering of a completion
	 * item.
	 */
	export enum CompletionItemTag {
		/**
		 * Render a completion as obsolete, usually using a strike-out.
		 */
		Deprecated = 1
	}

	/**
	 * A completion item represents a text snippet that is proposed to complete text that is being typed.
	 *
	 * It is sufficient to create a completion item from just a {@link CompletionItem.label label}. In that
	 * case the completion item will replace the {@link TextDocument.getWordRangeAtPosition word}
	 * until the cursor with the given label or {@link CompletionItem.insertText insertText}. Otherwise the
	 * given {@link CompletionItem.textEdit edit} is used.
	 *
	 * When selecting a completion item in the editor its defined or synthesized text edit will be applied
	 * to *all* cursors/selections whereas {@link CompletionItem.additionalTextEdits additionalTextEdits} will be
	 * applied as provided.
	 *
	 * @see {@link CompletionItemProvider.provideCompletionItems}
	 * @see {@link CompletionItemProvider.resolveCompletionItem}
	 */
	export class CompletionItem {

		/**
		 * The label of this completion item. By default
		 * this is also the text that is inserted when selecting
		 * this completion.
		 */
		label: string | CompletionItemLabel;

		/**
		 * The kind of this completion item. Based on the kind
		 * an icon is chosen by the editor.
		 */
		kind?: CompletionItemKind;

		/**
		 * Tags for this completion item.
		 */
		tags?: readonly CompletionItemTag[];

		/**
		 * A human-readable string with additional information
		 * about this item, like type or symbol information.
		 */
		detail?: string;

		/**
		 * A human-readable string that represents a doc-comment.
		 */
		documentation?: string | MarkdownString;

		/**
		 * A string that should be used when comparing this item
		 * with other items. When `falsy` the {@link CompletionItem.label label}
		 * is used.
		 *
		 * Note that `sortText` is only used for the initial ordering of completion
		 * items. When having a leading word (prefix) ordering is based on how
		 * well completions match that prefix and the initial ordering is only used
		 * when completions match equally well. The prefix is defined by the
		 * {@linkcode CompletionItem.range range}-property and can therefore be different
		 * for each completion.
		 */
		sortText?: string;

		/**
		 * A string that should be used when filtering a set of
		 * completion items. When `falsy` the {@link CompletionItem.label label}
		 * is used.
		 *
		 * Note that the filter text is matched against the leading word (prefix) which is defined
		 * by the {@linkcode CompletionItem.range range}-property.
		 */
		filterText?: string;

		/**
		 * Select this item when showing. *Note* that only one completion item can be selected and
		 * that the editor decides which item that is. The rule is that the *first* item of those
		 * that match best is selected.
		 */
		preselect?: boolean;

		/**
		 * A string or snippet that should be inserted in a document when selecting
		 * this completion. When `falsy` the {@link CompletionItem.label label}
		 * is used.
		 */
		insertText?: string | SnippetString;

		/**
		 * A range or a insert and replace range selecting the text that should be replaced by this completion item.
		 *
		 * When omitted, the range of the {@link TextDocument.getWordRangeAtPosition current word} is used as replace-range
		 * and as insert-range the start of the {@link TextDocument.getWordRangeAtPosition current word} to the
		 * current position is used.
		 *
		 * *Note 1:* A range must be a {@link Range.isSingleLine single line} and it must
		 * {@link Range.contains contain} the position at which completion has been {@link CompletionItemProvider.provideCompletionItems requested}.
		 * *Note 2:* A insert range must be a prefix of a replace range, that means it must be contained and starting at the same position.
		 */
		range?: Range | {
			/**
			 * The range that should be used when insert-accepting a completion. Must be a prefix of `replaceRange`.
			 */
			inserting: Range;
			/**
			 * The range that should be used when replace-accepting a completion.
			 */
			replacing: Range;
		};

		/**
		 * An optional set of characters that when pressed while this completion is active will accept it first and
		 * then type that character. *Note* that all commit characters should have `length=1` and that superfluous
		 * characters will be ignored.
		 */
		commitCharacters?: string[];

		/**
		 * Keep whitespace of the {@link CompletionItem.insertText insertText} as is. By default, the editor adjusts leading
		 * whitespace of new lines so that they match the indentation of the line for which the item is accepted - setting
		 * this to `true` will prevent that.
		 */
		keepWhitespace?: boolean;

		/**
		 * @deprecated Use `CompletionItem.insertText` and `CompletionItem.range` instead.
		 *
		 * An {@link TextEdit edit} which is applied to a document when selecting
		 * this completion. When an edit is provided the value of
		 * {@link CompletionItem.insertText insertText} is ignored.
		 *
		 * The {@link Range} of the edit must be single-line and on the same
		 * line completions were {@link CompletionItemProvider.provideCompletionItems requested} at.
		 */
		textEdit?: TextEdit;

		/**
		 * An optional array of additional {@link TextEdit text edits} that are applied when
		 * selecting this completion. Edits must not overlap with the main {@link CompletionItem.textEdit edit}
		 * nor with themselves.
		 */
		additionalTextEdits?: TextEdit[];

		/**
		 * An optional {@link Command} that is executed *after* inserting this completion. *Note* that
		 * additional modifications to the current document should be described with the
		 * {@link CompletionItem.additionalTextEdits additionalTextEdits}-property.
		 */
		command?: Command;

		/**
		 * Creates a new completion item.
		 *
		 * Completion items must have at least a {@link CompletionItem.label label} which then
		 * will be used as insert text as well as for sorting and filtering.
		 *
		 * @param label The label of the completion.
		 * @param kind The {@link CompletionItemKind kind} of the completion.
		 */
		constructor(label: string | CompletionItemLabel, kind?: CompletionItemKind);
	}

	/**
	 * Represents a collection of {@link CompletionItem completion items} to be presented
	 * in the editor.
	 */
	export class CompletionList<T extends CompletionItem = CompletionItem> {

		/**
		 * This list is not complete. Further typing should result in recomputing
		 * this list.
		 */
		isIncomplete?: boolean;

		/**
		 * The completion items.
		 */
		items: T[];

		/**
		 * Creates a new completion list.
		 *
		 * @param items The completion items.
		 * @param isIncomplete The list is not complete.
		 */
		constructor(items?: T[], isIncomplete?: boolean);
	}

	/**
	 * How a {@link CompletionItemProvider completion provider} was triggered
	 */
	export enum CompletionTriggerKind {
		/**
		 * Completion was triggered normally.
		 */
		Invoke = 0,
		/**
		 * Completion was triggered by a trigger character.
		 */
		TriggerCharacter = 1,
		/**
		 * Completion was re-triggered as current completion list is incomplete
		 */
		TriggerForIncompleteCompletions = 2
	}

	/**
	 * Contains additional information about the context in which
	 * {@link CompletionItemProvider.provideCompletionItems completion provider} is triggered.
	 */
	export interface CompletionContext {
		/**
		 * How the completion was triggered.
		 */
		readonly triggerKind: CompletionTriggerKind;

		/**
		 * Character that triggered the completion item provider.
		 *
		 * `undefined` if the provider was not triggered by a character.
		 *
		 * The trigger character is already in the document when the completion provider is triggered.
		 */
		readonly triggerCharacter: string | undefined;
	}

	/**
	 * The completion item provider interface defines the contract between extensions and
	 * [IntelliSense](https://code.visualstudio.com/docs/editor/intellisense).
	 *
	 * Providers can delay the computation of the {@linkcode CompletionItem.detail detail}
	 * and {@linkcode CompletionItem.documentation documentation} properties by implementing the
	 * {@linkcode CompletionItemProvider.resolveCompletionItem resolveCompletionItem}-function. However, properties that
	 * are needed for the initial sorting and filtering, like `sortText`, `filterText`, `insertText`, and `range`, must
	 * not be changed during resolve.
	 *
	 * Providers are asked for completions either explicitly by a user gesture or -depending on the configuration-
	 * implicitly when typing words or trigger characters.
	 */
	export interface CompletionItemProvider<T extends CompletionItem = CompletionItem> {

		/**
		 * Provide completion items for the given position and document.
		 *
		 * @param document The document in which the command was invoked.
		 * @param position The position at which the command was invoked.
		 * @param token A cancellation token.
		 * @param context How the completion was triggered.
		 *
		 * @returns An array of completions, a {@link CompletionList completion list}, or a thenable that resolves to either.
		 * The lack of a result can be signaled by returning `undefined`, `null`, or an empty array.
		 */
		provideCompletionItems(document: TextDocument, position: Position, token: CancellationToken, context: CompletionContext): ProviderResult<T[] | CompletionList<T>>;

		/**
		 * Given a completion item fill in more data, like {@link CompletionItem.documentation doc-comment}
		 * or {@link CompletionItem.detail details}.
		 *
		 * The editor will only resolve a completion item once.
		 *
		 * *Note* that this function is called when completion items are already showing in the UI or when an item has been
		 * selected for insertion. Because of that, no property that changes the presentation (label, sorting, filtering etc)
		 * or the (primary) insert behaviour ({@link CompletionItem.insertText insertText}) can be changed.
		 *
		 * This function may fill in {@link CompletionItem.additionalTextEdits additionalTextEdits}. However, that means an item might be
		 * inserted *before* resolving is done and in that case the editor will do a best effort to still apply those additional
		 * text edits.
		 *
		 * @param item A completion item currently active in the UI.
		 * @param token A cancellation token.
		 * @returns The resolved completion item or a thenable that resolves to of such. It is OK to return the given
		 * `item`. When no result is returned, the given `item` will be used.
		 */
		resolveCompletionItem?(item: T, token: CancellationToken): ProviderResult<T>;
	}


	/**
	 * The inline completion item provider interface defines the contract between extensions and
	 * the inline completion feature.
	 *
	 * Providers are asked for completions either explicitly by a user gesture or implicitly when typing.
	 */
	export interface InlineCompletionItemProvider {

		/**
		 * Provides inline completion items for the given position and document.
		 * If inline completions are enabled, this method will be called whenever the user stopped typing.
		 * It will also be called when the user explicitly triggers inline completions or explicitly asks for the next or previous inline completion.
		 * In that case, all available inline completions should be returned.
		 * `context.triggerKind` can be used to distinguish between these scenarios.
		 *
		 * @param document The document inline completions are requested for.
		 * @param position The position inline completions are requested for.
		 * @param context A context object with additional information.
		 * @param token A cancellation token.
		 * @returns An array of completion items or a thenable that resolves to an array of completion items.
		 */
		provideInlineCompletionItems(document: TextDocument, position: Position, context: InlineCompletionContext, token: CancellationToken): ProviderResult<InlineCompletionItem[] | InlineCompletionList>;
	}

	/**
	 * Represents a collection of {@link InlineCompletionItem inline completion items} to be presented
	 * in the editor.
	 */
	export class InlineCompletionList {
		/**
		 * The inline completion items.
		 */
		items: InlineCompletionItem[];

		/**
		 * Creates a new list of inline completion items.
		 */
		constructor(items: InlineCompletionItem[]);
	}

	/**
	 * Provides information about the context in which an inline completion was requested.
	 */
	export interface InlineCompletionContext {
		/**
		 * Describes how the inline completion was triggered.
		 */
		readonly triggerKind: InlineCompletionTriggerKind;

		/**
		 * Provides information about the currently selected item in the autocomplete widget if it is visible.
		 *
		 * If set, provided inline completions must extend the text of the selected item
		 * and use the same range, otherwise they are not shown as preview.
		 * As an example, if the document text is `console.` and the selected item is `.log` replacing the `.` in the document,
		 * the inline completion must also replace `.` and start with `.log`, for example `.log()`.
		 *
		 * Inline completion providers are requested again whenever the selected item changes.
		 */
		readonly selectedCompletionInfo: SelectedCompletionInfo | undefined;
	}

	/**
	 * Describes the currently selected completion item.
	 */
	export interface SelectedCompletionInfo {
		/**
		 * The range that will be replaced if this completion item is accepted.
		 */
		readonly range: Range;

		/**
		 * The text the range will be replaced with if this completion is accepted.
		 */
		readonly text: string;
	}

	/**
	 * Describes how an {@link InlineCompletionItemProvider inline completion provider} was triggered.
	 */
	export enum InlineCompletionTriggerKind {
		/**
		 * Completion was triggered explicitly by a user gesture.
		 * Return multiple completion items to enable cycling through them.
		 */
		Invoke = 0,

		/**
		 * Completion was triggered automatically while editing.
		 * It is sufficient to return a single completion item in this case.
		 */
		Automatic = 1,
	}

	/**
	 * An inline completion item represents a text snippet that is proposed inline to complete text that is being typed.
	 *
	 * @see {@link InlineCompletionItemProvider.provideInlineCompletionItems}
	 */
	export class InlineCompletionItem {
		/**
		 * The text to replace the range with. Must be set.
		 * Is used both for the preview and the accept operation.
		 */
		insertText: string | SnippetString;

		/**
		 * A text that is used to decide if this inline completion should be shown. When `falsy`
		 * the {@link InlineCompletionItem.insertText} is used.
		 *
		 * An inline completion is shown if the text to replace is a prefix of the filter text.
		 */
		filterText?: string;

		/**
		 * The range to replace.
		 * Must begin and end on the same line.
		 *
		 * Prefer replacements over insertions to provide a better experience when the user deletes typed text.
		 */
		range?: Range;

		/**
		 * An optional {@link Command} that is executed *after* inserting this completion.
		 */
		command?: Command;

		/**
		 * Creates a new inline completion item.
		 *
		 * @param insertText The text to replace the range with.
		 * @param range The range to replace. If not set, the word at the requested position will be used.
		 * @param command An optional {@link Command} that is executed *after* inserting this completion.
		 */
		constructor(insertText: string | SnippetString, range?: Range, command?: Command);
	}

	/**
	 * A document link is a range in a text document that links to an internal or external resource, like another
	 * text document or a web site.
	 */
	export class DocumentLink {

		/**
		 * The range this link applies to.
		 */
		range: Range;

		/**
		 * The uri this link points to.
		 */
		target?: Uri;

		/**
		 * The tooltip text when you hover over this link.
		 *
		 * If a tooltip is provided, is will be displayed in a string that includes instructions on how to
		 * trigger the link, such as `{0} (ctrl + click)`. The specific instructions vary depending on OS,
		 * user settings, and localization.
		 */
		tooltip?: string;

		/**
		 * Creates a new document link.
		 *
		 * @param range The range the document link applies to. Must not be empty.
		 * @param target The uri the document link points to.
		 */
		constructor(range: Range, target?: Uri);
	}

	/**
	 * The document link provider defines the contract between extensions and feature of showing
	 * links in the editor.
	 */
	export interface DocumentLinkProvider<T extends DocumentLink = DocumentLink> {

		/**
		 * Provide links for the given document. Note that the editor ships with a default provider that detects
		 * `http(s)` and `file` links.
		 *
		 * @param document The document in which the command was invoked.
		 * @param token A cancellation token.
		 * @returns An array of {@link DocumentLink document links} or a thenable that resolves to such. The lack of a result
		 * can be signaled by returning `undefined`, `null`, or an empty array.
		 */
		provideDocumentLinks(document: TextDocument, token: CancellationToken): ProviderResult<T[]>;

		/**
		 * Given a link fill in its {@link DocumentLink.target target}. This method is called when an incomplete
		 * link is selected in the UI. Providers can implement this method and return incomplete links
		 * (without target) from the {@linkcode DocumentLinkProvider.provideDocumentLinks provideDocumentLinks} method which
		 * often helps to improve performance.
		 *
		 * @param link The link that is to be resolved.
		 * @param token A cancellation token.
		 */
		resolveDocumentLink?(link: T, token: CancellationToken): ProviderResult<T>;
	}

	/**
	 * Represents a color in RGBA space.
	 */
	export class Color {

		/**
		 * The red component of this color in the range `[0-1]`.
		 */
		readonly red: number;

		/**
		 * The green component of this color in the range `[0-1]`.
		 */
		readonly green: number;

		/**
		 * The blue component of this color in the range `[0-1]`.
		 */
		readonly blue: number;

		/**
		 * The alpha component of this color in the range `[0-1]`.
		 */
		readonly alpha: number;

		/**
		 * Creates a new color instance.
		 *
		 * @param red The red component.
		 * @param green The green component.
		 * @param blue The blue component.
		 * @param alpha The alpha component.
		 */
		constructor(red: number, green: number, blue: number, alpha: number);
	}

	/**
	 * Represents a color range from a document.
	 */
	export class ColorInformation {

		/**
		 * The range in the document where this color appears.
		 */
		range: Range;

		/**
		 * The actual color value for this color range.
		 */
		color: Color;

		/**
		 * Creates a new color range.
		 *
		 * @param range The range the color appears in. Must not be empty.
		 * @param color The value of the color.
		 */
		constructor(range: Range, color: Color);
	}

	/**
	 * A color presentation object describes how a {@linkcode Color} should be represented as text and what
	 * edits are required to refer to it from source code.
	 *
	 * For some languages one color can have multiple presentations, e.g. css can represent the color red with
	 * the constant `Red`, the hex-value `#ff0000`, or in rgba and hsla forms. In csharp other representations
	 * apply, e.g. `System.Drawing.Color.Red`.
	 */
	export class ColorPresentation {

		/**
		 * The label of this color presentation. It will be shown on the color
		 * picker header. By default this is also the text that is inserted when selecting
		 * this color presentation.
		 */
		label: string;

		/**
		 * An {@link TextEdit edit} which is applied to a document when selecting
		 * this presentation for the color.  When `falsy` the {@link ColorPresentation.label label}
		 * is used.
		 */
		textEdit?: TextEdit;

		/**
		 * An optional array of additional {@link TextEdit text edits} that are applied when
		 * selecting this color presentation. Edits must not overlap with the main {@link ColorPresentation.textEdit edit} nor with themselves.
		 */
		additionalTextEdits?: TextEdit[];

		/**
		 * Creates a new color presentation.
		 *
		 * @param label The label of this color presentation.
		 */
		constructor(label: string);
	}

	/**
	 * The document color provider defines the contract between extensions and feature of
	 * picking and modifying colors in the editor.
	 */
	export interface DocumentColorProvider {

		/**
		 * Provide colors for the given document.
		 *
		 * @param document The document in which the command was invoked.
		 * @param token A cancellation token.
		 * @returns An array of {@link ColorInformation color information} or a thenable that resolves to such. The lack of a result
		 * can be signaled by returning `undefined`, `null`, or an empty array.
		 */
		provideDocumentColors(document: TextDocument, token: CancellationToken): ProviderResult<ColorInformation[]>;

		/**
		 * Provide {@link ColorPresentation representations} for a color.
		 *
		 * @param color The color to show and insert.
		 * @param context A context object with additional information
		 * @param token A cancellation token.
		 * @returns An array of color presentations or a thenable that resolves to such. The lack of a result
		 * can be signaled by returning `undefined`, `null`, or an empty array.
		 */
		provideColorPresentations(color: Color, context: {
			/**
			 * The text document that contains the color
			 */
			readonly document: TextDocument;
			/**
			 * The range in the document where the color is located.
			 */
			readonly range: Range;
		}, token: CancellationToken): ProviderResult<ColorPresentation[]>;
	}

	/**
	 * Inlay hint kinds.
	 *
	 * The kind of an inline hint defines its appearance, e.g the corresponding foreground and background colors are being
	 * used.
	 */
	export enum InlayHintKind {
		/**
		 * An inlay hint that is for a type annotation.
		 */
		Type = 1,
		/**
		 * An inlay hint that is for a parameter.
		 */
		Parameter = 2,
	}

	/**
	 * An inlay hint label part allows for interactive and composite labels of inlay hints.
	 */
	export class InlayHintLabelPart {

		/**
		 * The value of this label part.
		 */
		value: string;

		/**
		 * The tooltip text when you hover over this label part.
		 *
		 * *Note* that this property can be set late during
		 * {@link InlayHintsProvider.resolveInlayHint resolving} of inlay hints.
		 */
		tooltip?: string | MarkdownString | undefined;

		/**
		 * An optional {@link Location source code location} that represents this label
		 * part.
		 *
		 * The editor will use this location for the hover and for code navigation features: This
		 * part will become a clickable link that resolves to the definition of the symbol at the
		 * given location (not necessarily the location itself), it shows the hover that shows at
		 * the given location, and it shows a context menu with further code navigation commands.
		 *
		 * *Note* that this property can be set late during
		 * {@link InlayHintsProvider.resolveInlayHint resolving} of inlay hints.
		 */
		location?: Location | undefined;

		/**
		 * An optional command for this label part.
		 *
		 * The editor renders parts with commands as clickable links. The command is added to the context menu
		 * when a label part defines {@link InlayHintLabelPart.location location} and {@link InlayHintLabelPart.command command} .
		 *
		 * *Note* that this property can be set late during
		 * {@link InlayHintsProvider.resolveInlayHint resolving} of inlay hints.
		 */
		command?: Command | undefined;

		/**
		 * Creates a new inlay hint label part.
		 *
		 * @param value The value of the part.
		 */
		constructor(value: string);
	}

	/**
	 * Inlay hint information.
	 */
	export class InlayHint {

		/**
		 * The position of this hint.
		 */
		position: Position;

		/**
		 * The label of this hint. A human readable string or an array of {@link InlayHintLabelPart label parts}.
		 *
		 * *Note* that neither the string nor the label part can be empty.
		 */
		label: string | InlayHintLabelPart[];

		/**
		 * The tooltip text when you hover over this item.
		 *
		 * *Note* that this property can be set late during
		 * {@link InlayHintsProvider.resolveInlayHint resolving} of inlay hints.
		 */
		tooltip?: string | MarkdownString | undefined;

		/**
		 * The kind of this hint. The inlay hint kind defines the appearance of this inlay hint.
		 */
		kind?: InlayHintKind;

		/**
		 * Optional {@link TextEdit text edits} that are performed when accepting this inlay hint. The default
		 * gesture for accepting an inlay hint is the double click.
		 *
		 * *Note* that edits are expected to change the document so that the inlay hint (or its nearest variant) is
		 * now part of the document and the inlay hint itself is now obsolete.
		 *
		 * *Note* that this property can be set late during
		 * {@link InlayHintsProvider.resolveInlayHint resolving} of inlay hints.
		 */
		textEdits?: TextEdit[];

		/**
		 * Render padding before the hint. Padding will use the editor's background color,
		 * not the background color of the hint itself. That means padding can be used to visually
		 * align/separate an inlay hint.
		 */
		paddingLeft?: boolean;

		/**
		 * Render padding after the hint. Padding will use the editor's background color,
		 * not the background color of the hint itself. That means padding can be used to visually
		 * align/separate an inlay hint.
		 */
		paddingRight?: boolean;

		/**
		 * Creates a new inlay hint.
		 *
		 * @param position The position of the hint.
		 * @param label The label of the hint.
		 * @param kind The {@link InlayHintKind kind} of the hint.
		 */
		constructor(position: Position, label: string | InlayHintLabelPart[], kind?: InlayHintKind);
	}

	/**
	 * The inlay hints provider interface defines the contract between extensions and
	 * the inlay hints feature.
	 */
	export interface InlayHintsProvider<T extends InlayHint = InlayHint> {

		/**
		 * An optional event to signal that inlay hints from this provider have changed.
		 */
		onDidChangeInlayHints?: Event<void>;

		/**
		 * Provide inlay hints for the given range and document.
		 *
		 * *Note* that inlay hints that are not {@link Range.contains contained} by the given range are ignored.
		 *
		 * @param document The document in which the command was invoked.
		 * @param range The range for which inlay hints should be computed.
		 * @param token A cancellation token.
		 * @returns An array of inlay hints or a thenable that resolves to such.
		 */
		provideInlayHints(document: TextDocument, range: Range, token: CancellationToken): ProviderResult<T[]>;

		/**
		 * Given an inlay hint fill in {@link InlayHint.tooltip tooltip}, {@link InlayHint.textEdits text edits},
		 * or complete label {@link InlayHintLabelPart parts}.
		 *
		 * *Note* that the editor will resolve an inlay hint at most once.
		 *
		 * @param hint An inlay hint.
		 * @param token A cancellation token.
		 * @returns The resolved inlay hint or a thenable that resolves to such. It is OK to return the given `item`. When no result is returned, the given `item` will be used.
		 */
		resolveInlayHint?(hint: T, token: CancellationToken): ProviderResult<T>;
	}

	/**
	 * A line based folding range. To be valid, start and end line must be bigger than zero and smaller than the number of lines in the document.
	 * Invalid ranges will be ignored.
	 */
	export class FoldingRange {

		/**
		 * The zero-based start line of the range to fold. The folded area starts after the line's last character.
		 * To be valid, the end must be zero or larger and smaller than the number of lines in the document.
		 */
		start: number;

		/**
		 * The zero-based end line of the range to fold. The folded area ends with the line's last character.
		 * To be valid, the end must be zero or larger and smaller than the number of lines in the document.
		 */
		end: number;

		/**
		 * Describes the {@link FoldingRangeKind Kind} of the folding range such as {@link FoldingRangeKind.Comment Comment} or
		 * {@link FoldingRangeKind.Region Region}. The kind is used to categorize folding ranges and used by commands
		 * like 'Fold all comments'. See
		 * {@link FoldingRangeKind} for an enumeration of all kinds.
		 * If not set, the range is originated from a syntax element.
		 */
		kind?: FoldingRangeKind;

		/**
		 * Creates a new folding range.
		 *
		 * @param start The start line of the folded range.
		 * @param end The end line of the folded range.
		 * @param kind The kind of the folding range.
		 */
		constructor(start: number, end: number, kind?: FoldingRangeKind);
	}

	/**
	 * An enumeration of specific folding range kinds. The kind is an optional field of a {@link FoldingRange}
	 * and is used to distinguish specific folding ranges such as ranges originated from comments. The kind is used by commands like
	 * `Fold all comments` or `Fold all regions`.
	 * If the kind is not set on the range, the range originated from a syntax element other than comments, imports or region markers.
	 */
	export enum FoldingRangeKind {
		/**
		 * Kind for folding range representing a comment.
		 */
		Comment = 1,
		/**
		 * Kind for folding range representing a import.
		 */
		Imports = 2,
		/**
		 * Kind for folding range representing regions originating from folding markers like `#region` and `#endregion`.
		 */
		Region = 3
	}

	/**
	 * Folding context (for future use)
	 */
	export interface FoldingContext {
	}

	/**
	 * The folding range provider interface defines the contract between extensions and
	 * [Folding](https://code.visualstudio.com/docs/editor/codebasics#_folding) in the editor.
	 */
	export interface FoldingRangeProvider {

		/**
		 * An optional event to signal that the folding ranges from this provider have changed.
		 */
		onDidChangeFoldingRanges?: Event<void>;

		/**
		 * Returns a list of folding ranges or null and undefined if the provider
		 * does not want to participate or was cancelled.
		 * @param document The document in which the command was invoked.
		 * @param context Additional context information (for future use)
		 * @param token A cancellation token.
		 */
		provideFoldingRanges(document: TextDocument, context: FoldingContext, token: CancellationToken): ProviderResult<FoldingRange[]>;
	}

	/**
	 * A selection range represents a part of a selection hierarchy. A selection range
	 * may have a parent selection range that contains it.
	 */
	export class SelectionRange {

		/**
		 * The {@link Range} of this selection range.
		 */
		range: Range;

		/**
		 * The parent selection range containing this range.
		 */
		parent?: SelectionRange;

		/**
		 * Creates a new selection range.
		 *
		 * @param range The range of the selection range.
		 * @param parent The parent of the selection range.
		 */
		constructor(range: Range, parent?: SelectionRange);
	}

	/**
	 * The selection range provider interface defines the contract between extensions and the "Expand and Shrink Selection" feature.
	 */
	export interface SelectionRangeProvider {
		/**
		 * Provide selection ranges for the given positions.
		 *
		 * Selection ranges should be computed individually and independent for each position. The editor will merge
		 * and deduplicate ranges but providers must return hierarchies of selection ranges so that a range
		 * is {@link Range.contains contained} by its parent.
		 *
		 * @param document The document in which the command was invoked.
		 * @param positions The positions at which the command was invoked.
		 * @param token A cancellation token.
		 * @returns Selection ranges or a thenable that resolves to such. The lack of a result can be
		 * signaled by returning `undefined` or `null`.
		 */
		provideSelectionRanges(document: TextDocument, positions: readonly Position[], token: CancellationToken): ProviderResult<SelectionRange[]>;
	}

	/**
	 * Represents programming constructs like functions or constructors in the context
	 * of call hierarchy.
	 */
	export class CallHierarchyItem {
		/**
		 * The name of this item.
		 */
		name: string;

		/**
		 * The kind of this item.
		 */
		kind: SymbolKind;

		/**
		 * Tags for this item.
		 */
		tags?: readonly SymbolTag[];

		/**
		 * More detail for this item, e.g. the signature of a function.
		 */
		detail?: string;

		/**
		 * The resource identifier of this item.
		 */
		uri: Uri;

		/**
		 * The range enclosing this symbol not including leading/trailing whitespace but everything else, e.g. comments and code.
		 */
		range: Range;

		/**
		 * The range that should be selected and revealed when this symbol is being picked, e.g. the name of a function.
		 * Must be contained by the {@linkcode CallHierarchyItem.range range}.
		 */
		selectionRange: Range;

		/**
		 * Creates a new call hierarchy item.
		 */
		constructor(kind: SymbolKind, name: string, detail: string, uri: Uri, range: Range, selectionRange: Range);
	}

	/**
	 * Represents an incoming call, e.g. a caller of a method or constructor.
	 */
	export class CallHierarchyIncomingCall {

		/**
		 * The item that makes the call.
		 */
		from: CallHierarchyItem;

		/**
		 * The range at which at which the calls appears. This is relative to the caller
		 * denoted by {@linkcode CallHierarchyIncomingCall.from this.from}.
		 */
		fromRanges: Range[];

		/**
		 * Create a new call object.
		 *
		 * @param item The item making the call.
		 * @param fromRanges The ranges at which the calls appear.
		 */
		constructor(item: CallHierarchyItem, fromRanges: Range[]);
	}

	/**
	 * Represents an outgoing call, e.g. calling a getter from a method or a method from a constructor etc.
	 */
	export class CallHierarchyOutgoingCall {

		/**
		 * The item that is called.
		 */
		to: CallHierarchyItem;

		/**
		 * The range at which this item is called. This is the range relative to the caller, e.g the item
		 * passed to {@linkcode CallHierarchyProvider.provideCallHierarchyOutgoingCalls provideCallHierarchyOutgoingCalls}
		 * and not {@linkcode CallHierarchyOutgoingCall.to this.to}.
		 */
		fromRanges: Range[];

		/**
		 * Create a new call object.
		 *
		 * @param item The item being called
		 * @param fromRanges The ranges at which the calls appear.
		 */
		constructor(item: CallHierarchyItem, fromRanges: Range[]);
	}

	/**
	 * The call hierarchy provider interface describes the contract between extensions
	 * and the call hierarchy feature which allows to browse calls and caller of function,
	 * methods, constructor etc.
	 */
	export interface CallHierarchyProvider {

		/**
		 * Bootstraps call hierarchy by returning the item that is denoted by the given document
		 * and position. This item will be used as entry into the call graph. Providers should
		 * return `undefined` or `null` when there is no item at the given location.
		 *
		 * @param document The document in which the command was invoked.
		 * @param position The position at which the command was invoked.
		 * @param token A cancellation token.
		 * @returns One or multiple call hierarchy items or a thenable that resolves to such. The lack of a result can be
		 * signaled by returning `undefined`, `null`, or an empty array.
		 */
		prepareCallHierarchy(document: TextDocument, position: Position, token: CancellationToken): ProviderResult<CallHierarchyItem | CallHierarchyItem[]>;

		/**
		 * Provide all incoming calls for an item, e.g all callers for a method. In graph terms this describes directed
		 * and annotated edges inside the call graph, e.g the given item is the starting node and the result is the nodes
		 * that can be reached.
		 *
		 * @param item The hierarchy item for which incoming calls should be computed.
		 * @param token A cancellation token.
		 * @returns A set of incoming calls or a thenable that resolves to such. The lack of a result can be
		 * signaled by returning `undefined` or `null`.
		 */
		provideCallHierarchyIncomingCalls(item: CallHierarchyItem, token: CancellationToken): ProviderResult<CallHierarchyIncomingCall[]>;

		/**
		 * Provide all outgoing calls for an item, e.g call calls to functions, methods, or constructors from the given item. In
		 * graph terms this describes directed and annotated edges inside the call graph, e.g the given item is the starting
		 * node and the result is the nodes that can be reached.
		 *
		 * @param item The hierarchy item for which outgoing calls should be computed.
		 * @param token A cancellation token.
		 * @returns A set of outgoing calls or a thenable that resolves to such. The lack of a result can be
		 * signaled by returning `undefined` or `null`.
		 */
		provideCallHierarchyOutgoingCalls(item: CallHierarchyItem, token: CancellationToken): ProviderResult<CallHierarchyOutgoingCall[]>;
	}

	/**
	 * Represents an item of a type hierarchy, like a class or an interface.
	 */
	export class TypeHierarchyItem {
		/**
		 * The name of this item.
		 */
		name: string;

		/**
		 * The kind of this item.
		 */
		kind: SymbolKind;

		/**
		 * Tags for this item.
		 */
		tags?: ReadonlyArray<SymbolTag>;

		/**
		 * More detail for this item, e.g. the signature of a function.
		 */
		detail?: string;

		/**
		 * The resource identifier of this item.
		 */
		uri: Uri;

		/**
		 * The range enclosing this symbol not including leading/trailing whitespace
		 * but everything else, e.g. comments and code.
		 */
		range: Range;

		/**
		 * The range that should be selected and revealed when this symbol is being
		 * picked, e.g. the name of a class. Must be contained by the {@link TypeHierarchyItem.range range}-property.
		 */
		selectionRange: Range;

		/**
		 * Creates a new type hierarchy item.
		 *
		 * @param kind The kind of the item.
		 * @param name The name of the item.
		 * @param detail The details of the item.
		 * @param uri The Uri of the item.
		 * @param range The whole range of the item.
		 * @param selectionRange The selection range of the item.
		 */
		constructor(kind: SymbolKind, name: string, detail: string, uri: Uri, range: Range, selectionRange: Range);
	}

	/**
	 * The type hierarchy provider interface describes the contract between extensions
	 * and the type hierarchy feature.
	 */
	export interface TypeHierarchyProvider {

		/**
		 * Bootstraps type hierarchy by returning the item that is denoted by the given document
		 * and position. This item will be used as entry into the type graph. Providers should
		 * return `undefined` or `null` when there is no item at the given location.
		 *
		 * @param document The document in which the command was invoked.
		 * @param position The position at which the command was invoked.
		 * @param token A cancellation token.
		 * @returns One or multiple type hierarchy items or a thenable that resolves to such. The lack of a result can be
		 * signaled by returning `undefined`, `null`, or an empty array.
		 */
		prepareTypeHierarchy(document: TextDocument, position: Position, token: CancellationToken): ProviderResult<TypeHierarchyItem | TypeHierarchyItem[]>;

		/**
		 * Provide all supertypes for an item, e.g all types from which a type is derived/inherited. In graph terms this describes directed
		 * and annotated edges inside the type graph, e.g the given item is the starting node and the result is the nodes
		 * that can be reached.
		 *
		 * @param item The hierarchy item for which super types should be computed.
		 * @param token A cancellation token.
		 * @returns A set of direct supertypes or a thenable that resolves to such. The lack of a result can be
		 * signaled by returning `undefined` or `null`.
		 */
		provideTypeHierarchySupertypes(item: TypeHierarchyItem, token: CancellationToken): ProviderResult<TypeHierarchyItem[]>;

		/**
		 * Provide all subtypes for an item, e.g all types which are derived/inherited from the given item. In
		 * graph terms this describes directed and annotated edges inside the type graph, e.g the given item is the starting
		 * node and the result is the nodes that can be reached.
		 *
		 * @param item The hierarchy item for which subtypes should be computed.
		 * @param token A cancellation token.
		 * @returns A set of direct subtypes or a thenable that resolves to such. The lack of a result can be
		 * signaled by returning `undefined` or `null`.
		 */
		provideTypeHierarchySubtypes(item: TypeHierarchyItem, token: CancellationToken): ProviderResult<TypeHierarchyItem[]>;
	}

	/**
	 * Represents a list of ranges that can be edited together along with a word pattern to describe valid range contents.
	 */
	export class LinkedEditingRanges {
		/**
		 * Create a new linked editing ranges object.
		 *
		 * @param ranges A list of ranges that can be edited together
		 * @param wordPattern An optional word pattern that describes valid contents for the given ranges
		 */
		constructor(ranges: Range[], wordPattern?: RegExp);

		/**
		 * A list of ranges that can be edited together. The ranges must have
		 * identical length and text content. The ranges cannot overlap.
		 */
		readonly ranges: Range[];

		/**
		 * An optional word pattern that describes valid contents for the given ranges.
		 * If no pattern is provided, the language configuration's word pattern will be used.
		 */
		readonly wordPattern: RegExp | undefined;
	}

	/**
	 * The linked editing range provider interface defines the contract between extensions and
	 * the linked editing feature.
	 */
	export interface LinkedEditingRangeProvider {
		/**
		 * For a given position in a document, returns the range of the symbol at the position and all ranges
		 * that have the same content. A change to one of the ranges can be applied to all other ranges if the new content
		 * is valid. An optional word pattern can be returned with the result to describe valid contents.
		 * If no result-specific word pattern is provided, the word pattern from the language configuration is used.
		 *
		 * @param document The document in which the provider was invoked.
		 * @param position The position at which the provider was invoked.
		 * @param token A cancellation token.
		 * @returns A list of ranges that can be edited together
		 */
		provideLinkedEditingRanges(document: TextDocument, position: Position, token: CancellationToken): ProviderResult<LinkedEditingRanges>;
	}

	/**
	 * Identifies a {@linkcode DocumentDropEdit} or {@linkcode DocumentPasteEdit}
	 */
	export class DocumentDropOrPasteEditKind {
		static readonly Empty: DocumentDropOrPasteEditKind;

		/**
		 * The root kind for basic text edits.
		 *
		 * This kind should be used for edits that insert basic text into the document. A good example of this is
		 * an edit that pastes the clipboard text while also updating imports in the file based on the pasted text.
		 * For this we could use a kind such as `text.updateImports.someLanguageId`.
		 *
		 * Even though most drop/paste edits ultimately insert text, you should not use {@linkcode Text} as the base kind
		 * for every edit as this is redundant. Instead a more specific kind that describes the type of content being
		 * inserted should be used instead. For example, if the edit adds a Markdown link, use `markdown.link` since even
		 * though the content being inserted is text, it's more important to know that the edit inserts Markdown syntax.
		 */
		static readonly Text: DocumentDropOrPasteEditKind;

		/**
		 * Root kind for edits that update imports in a document in addition to inserting text.
		 */
		static readonly TextUpdateImports: DocumentDropOrPasteEditKind;

		/**
		 * Use {@linkcode DocumentDropOrPasteEditKind.Empty} instead.
		 */
		private constructor(value: string);

		/**
		 * The raw string value of the kind.
		 */
		readonly value: string;

		/**
		 * Create a new kind by appending additional scopes to the current kind.
		 *
		 * Does not modify the current kind.
		 */
		append(...parts: string[]): DocumentDropOrPasteEditKind;

		/**
		 * Checks if this kind intersects `other`.
		 *
		 * The kind `"text.plain"` for example intersects `text`, `"text.plain"` and `"text.plain.list"`,
		 * but not `"unicorn"`, or `"textUnicorn.plain"`.
		 *
		 * @param other Kind to check.
		 */
		intersects(other: DocumentDropOrPasteEditKind): boolean;

		/**
		 * Checks if `other` is a sub-kind of this `DocumentDropOrPasteEditKind`.
		 *
		 * The kind `"text.plain"` for example contains `"text.plain"` and `"text.plain.list"`,
		 * but not `"text"` or `"unicorn.text.plain"`.
		 *
		 * @param other Kind to check.
		 */
		contains(other: DocumentDropOrPasteEditKind): boolean;
	}

	/**
	 * An edit operation applied {@link DocumentDropEditProvider on drop}.
	 */
	export class DocumentDropEdit {
		/**
		 * Human readable label that describes the edit.
		 */
		title?: string;

		/**
		 * {@link DocumentDropOrPasteEditKind Kind} of the edit.
		 */
		kind?: DocumentDropOrPasteEditKind;

		/**
		 * Controls the ordering or multiple edits. If this provider yield to edits, it will be shown lower in the list.
		 */
		yieldTo?: readonly DocumentDropOrPasteEditKind[];

		/**
		 * The text or snippet to insert at the drop location.
		 */
		insertText: string | SnippetString;

		/**
		 * An optional additional edit to apply on drop.
		 */
		additionalEdit?: WorkspaceEdit;

		/**
		 * @param insertText The text or snippet to insert at the drop location.
		 * @param title Human readable label that describes the edit.
		 * @param kind {@link DocumentDropOrPasteEditKind Kind} of the edit.
		 */
		constructor(insertText: string | SnippetString, title?: string, kind?: DocumentDropOrPasteEditKind);
	}

	/**
	 * Provider which handles dropping of resources into a text editor.
	 *
	 * This allows users to drag and drop resources (including resources from external apps) into the editor. While dragging
	 * and dropping files, users can hold down `shift` to drop the file into the editor instead of opening it.
	 * Requires `editor.dropIntoEditor.enabled` to be on.
	 */
	export interface DocumentDropEditProvider<T extends DocumentDropEdit = DocumentDropEdit> {
		/**
		 * Provide edits which inserts the content being dragged and dropped into the document.
		 *
		 * @param document The document in which the drop occurred.
		 * @param position The position in the document where the drop occurred.
		 * @param dataTransfer A {@link DataTransfer} object that holds data about what is being dragged and dropped.
		 * @param token A cancellation token.
		 *
		 * @returns A {@link DocumentDropEdit} or a thenable that resolves to such. The lack of a result can be
		 * signaled by returning `undefined` or `null`.
		 */
		provideDocumentDropEdits(document: TextDocument, position: Position, dataTransfer: DataTransfer, token: CancellationToken): ProviderResult<T | T[]>;

		/**
		 * Optional method which fills in the {@linkcode DocumentDropEdit.additionalEdit} before the edit is applied.
		 *
		 * This is called once per edit and should be used if generating the complete edit may take a long time.
		 * Resolve can only be used to change {@link DocumentDropEdit.additionalEdit}.
		 *
		 * @param edit The {@linkcode DocumentDropEdit} to resolve.
		 * @param token A cancellation token.
		 *
		 * @returns The resolved edit or a thenable that resolves to such. It is OK to return the given
		 * `edit`. If no result is returned, the given `edit` is used.
		 */
		resolveDocumentDropEdit?(edit: T, token: CancellationToken): ProviderResult<T>;
	}

	/**
	 * Provides additional metadata about how a {@linkcode DocumentDropEditProvider} works.
	 */
	export interface DocumentDropEditProviderMetadata {
		/**
		 * List of {@link DocumentDropOrPasteEditKind kinds} that the provider may return in {@linkcode DocumentDropEditProvider.provideDocumentDropEdits provideDocumentDropEdits}.
		 *
		 * This is used to filter out providers when a specific {@link DocumentDropOrPasteEditKind kind} of edit is requested.
		 */
		readonly providedDropEditKinds?: readonly DocumentDropOrPasteEditKind[];

		/**
		 * List of {@link DataTransfer} mime types that the provider can handle.
		 *
		 * This can either be an exact mime type such as `image/png`, or a wildcard pattern such as `image/*`.
		 *
		 * Use `text/uri-list` for resources dropped from the explorer or other tree views in the workbench.
		 *
		 * Use `files` to indicate that the provider should be invoked if any {@link DataTransferFile files} are present in the {@link DataTransfer}.
		 * Note that {@link DataTransferFile} entries are only created when dropping content from outside the editor, such as
		 * from the operating system.
		 */
		readonly dropMimeTypes: readonly string[];
	}


	/**
	 * The reason why paste edits were requested.
	 */
	export enum DocumentPasteTriggerKind {
		/**
		 * Pasting was requested as part of a normal paste operation.
		 */
		Automatic = 0,

		/**
		 * Pasting was requested by the user with the `paste as` command.
		 */
		PasteAs = 1,
	}

	/**
	 * Additional information about the paste operation.
	 */
	export interface DocumentPasteEditContext {

		/**
		 * Requested kind of paste edits to return.
		 *
		 * When a explicit kind if requested by {@linkcode DocumentPasteTriggerKind.PasteAs PasteAs}, providers are
		 * encourage to be more flexible when generating an edit of the requested kind.
		 */
		readonly only: DocumentDropOrPasteEditKind | undefined;

		/**
		 * The reason why paste edits were requested.
		 */
		readonly triggerKind: DocumentPasteTriggerKind;
	}

	/**
	 * Provider invoked when the user copies or pastes in a {@linkcode TextDocument}.
	 */
	export interface DocumentPasteEditProvider<T extends DocumentPasteEdit = DocumentPasteEdit> {

		/**
		 * Optional method invoked after the user copies from a {@link TextEditor text editor}.
		 *
		 * This allows the provider to attach metadata about the copied text to the {@link DataTransfer}. This data
		 * transfer is then passed back to providers in {@linkcode provideDocumentPasteEdits}.
		 *
		 * Note that currently any changes to the {@linkcode DataTransfer} are isolated to the current editor window.
		 * This means that any added metadata cannot be seen by other editor windows or by other applications.
		 *
		 * @param document Text document where the copy took place.
		 * @param ranges Ranges being copied in {@linkcode document}.
		 * @param dataTransfer The data transfer associated with the copy. You can store additional values on this for
		 * later use in {@linkcode provideDocumentPasteEdits}. This object is only valid for the duration of this method.
		 * @param token A cancellation token.
		 *
		 * @return Optional thenable that resolves when all changes to the `dataTransfer` are complete.
		 */
		prepareDocumentPaste?(document: TextDocument, ranges: readonly Range[], dataTransfer: DataTransfer, token: CancellationToken): void | Thenable<void>;

		/**
		 * Invoked before the user pastes into a {@link TextEditor text editor}.
		 *
		 * Returned edits can replace the standard pasting behavior.
		 *
		 * @param document Document being pasted into
		 * @param ranges Range in the {@linkcode document} to paste into.
		 * @param dataTransfer The {@link DataTransfer data transfer} associated with the paste. This object is only
		 * valid for the duration of the paste operation.
		 * @param context Additional context for the paste.
		 * @param token A cancellation token.
		 *
		 * @return Set of potential {@link DocumentPasteEdit edits} that can apply the paste. Only a single returned
		 * {@linkcode DocumentPasteEdit} is applied at a time. If multiple edits are returned from all providers, then
		 * the first is automatically applied and a widget is shown that lets the user switch to the other edits.
		 */
		provideDocumentPasteEdits?(document: TextDocument, ranges: readonly Range[], dataTransfer: DataTransfer, context: DocumentPasteEditContext, token: CancellationToken): ProviderResult<T[]>;

		/**
		 * Optional method which fills in the {@linkcode DocumentPasteEdit.additionalEdit} before the edit is applied.
		 *
		 * This is called once per edit and should be used if generating the complete edit may take a long time.
		 * Resolve can only be used to change {@linkcode DocumentPasteEdit.insertText} or {@linkcode DocumentPasteEdit.additionalEdit}.
		 *
		 * @param pasteEdit The {@linkcode DocumentPasteEdit} to resolve.
		 * @param token A cancellation token.
		 *
		 * @returns The resolved paste edit or a thenable that resolves to such. It is OK to return the given
		 * `pasteEdit`. If no result is returned, the given `pasteEdit` is used.
		 */
		resolveDocumentPasteEdit?(pasteEdit: T, token: CancellationToken): ProviderResult<T>;
	}

	/**
	 * An edit the applies a paste operation.
	 */
	export class DocumentPasteEdit {

		/**
		 * Human readable label that describes the edit.
		 */
		title: string;

		/**
		 * {@link DocumentDropOrPasteEditKind Kind} of the edit.
		 */
		kind: DocumentDropOrPasteEditKind;

		/**
		 * The text or snippet to insert at the pasted locations.
		 *
		 * If your edit requires more advanced insertion logic, set this to an empty string and provide an {@link DocumentPasteEdit.additionalEdit additional edit} instead.
		 */
		insertText: string | SnippetString;

		/**
		 * An optional additional edit to apply on paste.
		 */
		additionalEdit?: WorkspaceEdit;

		/**
		 * Controls ordering when multiple paste edits can potentially be applied.
		 *
		 * If this edit yields to another, it will be shown lower in the list of possible paste edits shown to the user.
		 */
		yieldTo?: readonly DocumentDropOrPasteEditKind[];

		/**
		 * Create a new paste edit.
		 *
		 * @param insertText The text or snippet to insert at the pasted locations.
		 * @param title Human readable label that describes the edit.
		 * @param kind {@link DocumentDropOrPasteEditKind Kind} of the edit.
		 */
		constructor(insertText: string | SnippetString, title: string, kind: DocumentDropOrPasteEditKind);
	}

	/**
	 * Provides additional metadata about how a {@linkcode DocumentPasteEditProvider} works.
	 */
	export interface DocumentPasteProviderMetadata {
		/**
		 * List of {@link DocumentDropOrPasteEditKind kinds} that the provider may return in {@linkcode DocumentPasteEditProvider.provideDocumentPasteEdits provideDocumentPasteEdits}.
		 *
		 * This is used to filter out providers when a specific {@link DocumentDropOrPasteEditKind kind} of edit is requested.
		 */
		readonly providedPasteEditKinds: readonly DocumentDropOrPasteEditKind[];

		/**
		 * Mime types that {@linkcode DocumentPasteEditProvider.prepareDocumentPaste prepareDocumentPaste} may add on copy.
		 */
		readonly copyMimeTypes?: readonly string[];

		/**
		 * Mime types that {@linkcode DocumentPasteEditProvider.provideDocumentPasteEdits provideDocumentPasteEdits} should be invoked for.
		 *
		 * This can either be an exact mime type such as `image/png`, or a wildcard pattern such as `image/*`.
		 *
		 * Use `text/uri-list` for resources dropped from the explorer or other tree views in the workbench.
		 *
		 * Use `files` to indicate that the provider should be invoked if any {@link DataTransferFile files} are present in the {@linkcode DataTransfer}.
		 * Note that {@linkcode DataTransferFile} entries are only created when pasting content from outside the editor, such as
		 * from the operating system.
		 */
		readonly pasteMimeTypes?: readonly string[];
	}

	/**
	 * A tuple of two characters, like a pair of
	 * opening and closing brackets.
	 */
	export type CharacterPair = [string, string];

	/**
	 * Describes how comments for a language work.
	 */
	export interface CommentRule {

		/**
		 * The line comment token, like `// this is a comment`
		 */
		lineComment?: string;

		/**
		 * The block comment character pair, like `/* block comment *&#47;`
		 */
		blockComment?: CharacterPair;
	}

	/**
	 * Describes indentation rules for a language.
	 */
	export interface IndentationRule {
		/**
		 * If a line matches this pattern, then all the lines after it should be unindented once (until another rule matches).
		 */
		decreaseIndentPattern: RegExp;
		/**
		 * If a line matches this pattern, then all the lines after it should be indented once (until another rule matches).
		 */
		increaseIndentPattern: RegExp;
		/**
		 * If a line matches this pattern, then **only the next line** after it should be indented once.
		 */
		indentNextLinePattern?: RegExp;
		/**
		 * If a line matches this pattern, then its indentation should not be changed and it should not be evaluated against the other rules.
		 */
		unIndentedLinePattern?: RegExp;
	}

	/**
	 * Describes what to do with the indentation when pressing Enter.
	 */
	export enum IndentAction {
		/**
		 * Insert new line and copy the previous line's indentation.
		 */
		None = 0,
		/**
		 * Insert new line and indent once (relative to the previous line's indentation).
		 */
		Indent = 1,
		/**
		 * Insert two new lines:
		 *  - the first one indented which will hold the cursor
		 *  - the second one at the same indentation level
		 */
		IndentOutdent = 2,
		/**
		 * Insert new line and outdent once (relative to the previous line's indentation).
		 */
		Outdent = 3
	}

	/**
	 * Describes what to do when pressing Enter.
	 */
	export interface EnterAction {
		/**
		 * Describe what to do with the indentation.
		 */
		indentAction: IndentAction;
		/**
		 * Describes text to be appended after the new line and after the indentation.
		 */
		appendText?: string;
		/**
		 * Describes the number of characters to remove from the new line's indentation.
		 */
		removeText?: number;
	}

	/**
	 * Describes a rule to be evaluated when pressing Enter.
	 */
	export interface OnEnterRule {
		/**
		 * This rule will only execute if the text before the cursor matches this regular expression.
		 */
		beforeText: RegExp;
		/**
		 * This rule will only execute if the text after the cursor matches this regular expression.
		 */
		afterText?: RegExp;
		/**
		 * This rule will only execute if the text above the current line matches this regular expression.
		 */
		previousLineText?: RegExp;
		/**
		 * The action to execute.
		 */
		action: EnterAction;
	}

	/**
	 * Enumeration of commonly encountered syntax token types.
	 */
	export enum SyntaxTokenType {
		/**
		 * Everything except tokens that are part of comments, string literals and regular expressions.
		 */
		Other = 0,
		/**
		 * A comment.
		 */
		Comment = 1,
		/**
		 * A string literal.
		 */
		String = 2,
		/**
		 * A regular expression.
		 */
		RegEx = 3
	}

	/**
	 * Describes pairs of strings where the close string will be automatically inserted when typing the opening string.
	 */
	export interface AutoClosingPair {
		/**
		 * The string that will trigger the automatic insertion of the closing string.
		 */
		open: string;
		/**
		 * The closing string that will be automatically inserted when typing the opening string.
		 */
		close: string;
		/**
		 * A set of tokens where the pair should not be auto closed.
		 */
		notIn?: SyntaxTokenType[];
	}

	/**
	 * The language configuration interfaces defines the contract between extensions
	 * and various editor features, like automatic bracket insertion, automatic indentation etc.
	 */
	export interface LanguageConfiguration {
		/**
		 * The language's comment settings.
		 */
		comments?: CommentRule;
		/**
		 * The language's brackets.
		 * This configuration implicitly affects pressing Enter around these brackets.
		 */
		brackets?: CharacterPair[];
		/**
		 * The language's word definition.
		 * If the language supports Unicode identifiers (e.g. JavaScript), it is preferable
		 * to provide a word definition that uses exclusion of known separators.
		 * e.g.: A regex that matches anything except known separators (and dot is allowed to occur in a floating point number):
		 * ```
		 * /(-?\d*\.\d\w*)|([^\`\~\!\@\#\%\^\&\*\(\)\-\=\+\[\{\]\}\\\|\;\:\'\"\,\.\<\>\/\?\s]+)/g
		 * ```
		 */
		wordPattern?: RegExp;
		/**
		 * The language's indentation settings.
		 */
		indentationRules?: IndentationRule;
		/**
		 * The language's rules to be evaluated when pressing Enter.
		 */
		onEnterRules?: OnEnterRule[];
		/**
		 * The language's auto closing pairs.
		 */
		autoClosingPairs?: AutoClosingPair[];

		/**
		 * **Deprecated** Do not use.
		 *
		 * @deprecated Will be replaced by a better API soon.
		 */
		__electricCharacterSupport?: {
			/**
			 * This property is deprecated and will be **ignored** from
			 * the editor.
			 * @deprecated
			 */
			brackets?: any;
			/**
			 * This property is deprecated and not fully supported anymore by
			 * the editor (scope and lineStart are ignored).
			 * Use the autoClosingPairs property in the language configuration file instead.
			 * @deprecated
			 */
			docComment?: {
				/**
				 * @deprecated
				 */
				scope: string;
				/**
				 * @deprecated
				 */
				open: string;
				/**
				 * @deprecated
				 */
				lineStart: string;
				/**
				 * @deprecated
				 */
				close?: string;
			};
		};

		/**
		 * **Deprecated** Do not use.
		 *
		 * @deprecated * Use the autoClosingPairs property in the language configuration file instead.
		 */
		__characterPairSupport?: {
			/**
			 * @deprecated
			 */
			autoClosingPairs: {
				/**
				 * @deprecated
				 */
				open: string;
				/**
				 * @deprecated
				 */
				close: string;
				/**
				 * @deprecated
				 */
				notIn?: string[];
			}[];
		};
	}

	/**
	 * The configuration target
	 */
	export enum ConfigurationTarget {
		/**
		 * Global configuration
		 */
		Global = 1,

		/**
		 * Workspace configuration
		 */
		Workspace = 2,

		/**
		 * Workspace folder configuration
		 */
		WorkspaceFolder = 3
	}

	/**
	 * Represents the configuration. It is a merged view of
	 *
	 * - *Default Settings*
	 * - *Global (User) Settings*
	 * - *Workspace settings*
	 * - *Workspace Folder settings* - From one of the {@link workspace.workspaceFolders Workspace Folders} under which requested resource belongs to.
	 * - *Language settings* - Settings defined under requested language.
	 *
	 * The *effective* value (returned by {@linkcode WorkspaceConfiguration.get get}) is computed by overriding or merging the values in the following order:
	 *
	 * 1. `defaultValue` (if defined in `package.json` otherwise derived from the value's type)
	 * 1. `globalValue` (if defined)
	 * 1. `workspaceValue` (if defined)
	 * 1. `workspaceFolderValue` (if defined)
	 * 1. `defaultLanguageValue` (if defined)
	 * 1. `globalLanguageValue` (if defined)
	 * 1. `workspaceLanguageValue` (if defined)
	 * 1. `workspaceFolderLanguageValue` (if defined)
	 *
	 * **Note:** Only `object` value types are merged and all other value types are overridden.
	 *
	 * Example 1: Overriding
	 *
	 * ```ts
	 * defaultValue = 'on';
	 * globalValue = 'relative'
	 * workspaceFolderValue = 'off'
	 * value = 'off'
	 * ```
	 *
	 * Example 2: Language Values
	 *
	 * ```ts
	 * defaultValue = 'on';
	 * globalValue = 'relative'
	 * workspaceFolderValue = 'off'
	 * globalLanguageValue = 'on'
	 * value = 'on'
	 * ```
	 *
	 * Example 3: Object Values
	 *
	 * ```ts
	 * defaultValue = { "a": 1, "b": 2 };
	 * globalValue = { "b": 3, "c": 4 };
	 * value = { "a": 1, "b": 3, "c": 4 };
	 * ```
	 *
	 * *Note:* Workspace and Workspace Folder configurations contains `launch` and `tasks` settings. Their basename will be
	 * part of the section identifier. The following snippets shows how to retrieve all configurations
	 * from `launch.json`:
	 *
	 * ```ts
	 * // launch.json configuration
	 * const config = workspace.getConfiguration('launch', vscode.workspace.workspaceFolders[0].uri);
	 *
	 * // retrieve values
	 * const values = config.get('configurations');
	 * ```
	 *
	 * Refer to [Settings](https://code.visualstudio.com/docs/getstarted/settings) for more information.
	 */
	export interface WorkspaceConfiguration {

		/**
		 * Return a value from this configuration.
		 *
		 * @param section Configuration name, supports _dotted_ names.
		 * @returns The value `section` denotes or `undefined`.
		 */
		get<T>(section: string): T | undefined;

		/**
		 * Return a value from this configuration.
		 *
		 * @param section Configuration name, supports _dotted_ names.
		 * @param defaultValue A value should be returned when no value could be found, is `undefined`.
		 * @returns The value `section` denotes or the default.
		 */
		get<T>(section: string, defaultValue: T): T;

		/**
		 * Check if this configuration has a certain value.
		 *
		 * @param section Configuration name, supports _dotted_ names.
		 * @returns `true` if the section doesn't resolve to `undefined`.
		 */
		has(section: string): boolean;

		/**
		 * Retrieve all information about a configuration setting. A configuration value
		 * often consists of a *default* value, a global or installation-wide value,
		 * a workspace-specific value, folder-specific value
		 * and language-specific values (if {@link WorkspaceConfiguration} is scoped to a language).
		 *
		 * Also provides all language ids under which the given configuration setting is defined.
		 *
		 * *Note:* The configuration name must denote a leaf in the configuration tree
		 * (`editor.fontSize` vs `editor`) otherwise no result is returned.
		 *
		 * @param section Configuration name, supports _dotted_ names.
		 * @returns Information about a configuration setting or `undefined`.
		 */
		inspect<T>(section: string): {

			/**
			 * The fully qualified key of the configuration value
			 */
			key: string;

			/**
			 * The default value which is used when no other value is defined
			 */
			defaultValue?: T;

			/**
			 * The global or installation-wide value.
			 */
			globalValue?: T;

			/**
			 * The workspace-specific value.
			 */
			workspaceValue?: T;

			/**
			 * The workspace-folder-specific value.
			 */
			workspaceFolderValue?: T;

			/**
			 * Language specific default value when this configuration value is created for a {@link ConfigurationScope language scope}.
			 */
			defaultLanguageValue?: T;

			/**
			 * Language specific global value when this configuration value is created for a {@link ConfigurationScope language scope}.
			 */
			globalLanguageValue?: T;

			/**
			 * Language specific workspace value when this configuration value is created for a {@link ConfigurationScope language scope}.
			 */
			workspaceLanguageValue?: T;

			/**
			 * Language specific workspace-folder value when this configuration value is created for a {@link ConfigurationScope language scope}.
			 */
			workspaceFolderLanguageValue?: T;

			/**
			 * All language identifiers for which this configuration is defined.
			 */
			languageIds?: string[];

		} | undefined;

		/**
		 * Update a configuration value. The updated configuration values are persisted.
		 *
		 * A value can be changed in
		 *
		 * - {@link ConfigurationTarget.Global Global settings}: Changes the value for all instances of the editor.
		 * - {@link ConfigurationTarget.Workspace Workspace settings}: Changes the value for current workspace, if available.
		 * - {@link ConfigurationTarget.WorkspaceFolder Workspace folder settings}: Changes the value for settings from one of the {@link workspace.workspaceFolders Workspace Folders} under which the requested resource belongs to.
		 * - Language settings: Changes the value for the requested languageId.
		 *
		 * *Note:* To remove a configuration value use `undefined`, like so: `config.update('somekey', undefined)`
		 *
		 * @param section Configuration name, supports _dotted_ names.
		 * @param value The new value.
		 * @param configurationTarget The {@link ConfigurationTarget configuration target} or a boolean value.
		 *	- If `true` updates {@link ConfigurationTarget.Global Global settings}.
		 *	- If `false` updates {@link ConfigurationTarget.Workspace Workspace settings}.
		 *	- If `undefined` or `null` updates to {@link ConfigurationTarget.WorkspaceFolder Workspace folder settings} if configuration is resource specific,
		 * 	otherwise to {@link ConfigurationTarget.Workspace Workspace settings}.
		 * @param overrideInLanguage Whether to update the value in the scope of requested languageId or not.
		 *	- If `true` updates the value under the requested languageId.
		 *	- If `undefined` updates the value under the requested languageId only if the configuration is defined for the language.
		 * @throws error while updating
		 *	- configuration which is not registered.
		 *	- window configuration to workspace folder
		 *	- configuration to workspace or workspace folder when no workspace is opened.
		 *	- configuration to workspace folder when there is no workspace folder settings.
		 *	- configuration to workspace folder when {@link WorkspaceConfiguration} is not scoped to a resource.
		 */
		update(section: string, value: any, configurationTarget?: ConfigurationTarget | boolean | null, overrideInLanguage?: boolean): Thenable<void>;

		/**
		 * Readable dictionary that backs this configuration.
		 */
		readonly [key: string]: any;
	}

	/**
	 * Represents a location inside a resource, such as a line
	 * inside a text file.
	 */
	export class Location {

		/**
		 * The resource identifier of this location.
		 */
		uri: Uri;

		/**
		 * The document range of this location.
		 */
		range: Range;

		/**
		 * Creates a new location object.
		 *
		 * @param uri The resource identifier.
		 * @param rangeOrPosition The range or position. Positions will be converted to an empty range.
		 */
		constructor(uri: Uri, rangeOrPosition: Range | Position);
	}

	/**
	 * Represents the connection of two locations. Provides additional metadata over normal {@link Location locations},
	 * including an origin range.
	 */
	export interface LocationLink {
		/**
		 * Span of the origin of this link.
		 *
		 * Used as the underlined span for mouse definition hover. Defaults to the word range at
		 * the definition position.
		 */
		originSelectionRange?: Range;

		/**
		 * The target resource identifier of this link.
		 */
		targetUri: Uri;

		/**
		 * The full target range of this link.
		 */
		targetRange: Range;

		/**
		 * The span of this link.
		 */
		targetSelectionRange?: Range;
	}

	/**
	 * The event that is fired when diagnostics change.
	 */
	export interface DiagnosticChangeEvent {

		/**
		 * An array of resources for which diagnostics have changed.
		 */
		readonly uris: readonly Uri[];
	}

	/**
	 * Represents the severity of diagnostics.
	 */
	export enum DiagnosticSeverity {

		/**
		 * Something not allowed by the rules of a language or other means.
		 */
		Error = 0,

		/**
		 * Something suspicious but allowed.
		 */
		Warning = 1,

		/**
		 * Something to inform about but not a problem.
		 */
		Information = 2,

		/**
		 * Something to hint to a better way of doing it, like proposing
		 * a refactoring.
		 */
		Hint = 3
	}

	/**
	 * Represents a related message and source code location for a diagnostic. This should be
	 * used to point to code locations that cause or related to a diagnostics, e.g. when duplicating
	 * a symbol in a scope.
	 */
	export class DiagnosticRelatedInformation {

		/**
		 * The location of this related diagnostic information.
		 */
		location: Location;

		/**
		 * The message of this related diagnostic information.
		 */
		message: string;

		/**
		 * Creates a new related diagnostic information object.
		 *
		 * @param location The location.
		 * @param message The message.
		 */
		constructor(location: Location, message: string);
	}

	/**
	 * Additional metadata about the type of a diagnostic.
	 */
	export enum DiagnosticTag {
		/**
		 * Unused or unnecessary code.
		 *
		 * Diagnostics with this tag are rendered faded out. The amount of fading
		 * is controlled by the `"editorUnnecessaryCode.opacity"` theme color. For
		 * example, `"editorUnnecessaryCode.opacity": "#000000c0"` will render the
		 * code with 75% opacity. For high contrast themes, use the
		 * `"editorUnnecessaryCode.border"` theme color to underline unnecessary code
		 * instead of fading it out.
		 */
		Unnecessary = 1,

		/**
		 * Deprecated or obsolete code.
		 *
		 * Diagnostics with this tag are rendered with a strike through.
		 */
		Deprecated = 2,
	}

	/**
	 * Represents a diagnostic, such as a compiler error or warning. Diagnostic objects
	 * are only valid in the scope of a file.
	 */
	export class Diagnostic {

		/**
		 * The range to which this diagnostic applies.
		 */
		range: Range;

		/**
		 * The human-readable message.
		 */
		message: string;

		/**
		 * The severity, default is {@link DiagnosticSeverity.Error error}.
		 */
		severity: DiagnosticSeverity;

		/**
		 * A human-readable string describing the source of this
		 * diagnostic, e.g. 'typescript' or 'super lint'.
		 */
		source?: string;

		/**
		 * A code or identifier for this diagnostic.
		 * Should be used for later processing, e.g. when providing {@link CodeActionContext code actions}.
		 */
		code?: string | number | {
			/**
			 * A code or identifier for this diagnostic.
			 * Should be used for later processing, e.g. when providing {@link CodeActionContext code actions}.
			 */
			value: string | number;

			/**
			 * A target URI to open with more information about the diagnostic error.
			 */
			target: Uri;
		};

		/**
		 * An array of related diagnostic information, e.g. when symbol-names within
		 * a scope collide all definitions can be marked via this property.
		 */
		relatedInformation?: DiagnosticRelatedInformation[];

		/**
		 * Additional metadata about the diagnostic.
		 */
		tags?: DiagnosticTag[];

		/**
		 * Creates a new diagnostic object.
		 *
		 * @param range The range to which this diagnostic applies.
		 * @param message The human-readable message.
		 * @param severity The severity, default is {@link DiagnosticSeverity.Error error}.
		 */
		constructor(range: Range, message: string, severity?: DiagnosticSeverity);
	}

	/**
	 * A diagnostics collection is a container that manages a set of
	 * {@link Diagnostic diagnostics}. Diagnostics are always scopes to a
	 * diagnostics collection and a resource.
	 *
	 * To get an instance of a `DiagnosticCollection` use
	 * {@link languages.createDiagnosticCollection createDiagnosticCollection}.
	 */
	export interface DiagnosticCollection extends Iterable<[uri: Uri, diagnostics: readonly Diagnostic[]]> {

		/**
		 * The name of this diagnostic collection, for instance `typescript`. Every diagnostic
		 * from this collection will be associated with this name. Also, the task framework uses this
		 * name when defining [problem matchers](https://code.visualstudio.com/docs/editor/tasks#_defining-a-problem-matcher).
		 */
		readonly name: string;

		/**
		 * Assign diagnostics for given resource. Will replace
		 * existing diagnostics for that resource.
		 *
		 * @param uri A resource identifier.
		 * @param diagnostics Array of diagnostics or `undefined`
		 */
		set(uri: Uri, diagnostics: readonly Diagnostic[] | undefined): void;

		/**
		 * Replace diagnostics for multiple resources in this collection.
		 *
		 *  _Note_ that multiple tuples of the same uri will be merged, e.g
		 * `[[file1, [d1]], [file1, [d2]]]` is equivalent to `[[file1, [d1, d2]]]`.
		 * If a diagnostics item is `undefined` as in `[file1, undefined]`
		 * all previous but not subsequent diagnostics are removed.
		 *
		 * @param entries An array of tuples, like `[[file1, [d1, d2]], [file2, [d3, d4, d5]]]`, or `undefined`.
		 */
		set(entries: ReadonlyArray<[Uri, readonly Diagnostic[] | undefined]>): void;

		/**
		 * Remove all diagnostics from this collection that belong
		 * to the provided `uri`. The same as `#set(uri, undefined)`.
		 *
		 * @param uri A resource identifier.
		 */
		delete(uri: Uri): void;

		/**
		 * Remove all diagnostics from this collection. The same
		 * as calling `#set(undefined)`;
		 */
		clear(): void;

		/**
		 * Iterate over each entry in this collection.
		 *
		 * @param callback Function to execute for each entry.
		 * @param thisArg The `this` context used when invoking the handler function.
		 */
		forEach(callback: (uri: Uri, diagnostics: readonly Diagnostic[], collection: DiagnosticCollection) => any, thisArg?: any): void;

		/**
		 * Get the diagnostics for a given resource. *Note* that you cannot
		 * modify the diagnostics-array returned from this call.
		 *
		 * @param uri A resource identifier.
		 * @returns An immutable array of {@link Diagnostic diagnostics} or `undefined`.
		 */
		get(uri: Uri): readonly Diagnostic[] | undefined;

		/**
		 * Check if this collection contains diagnostics for a
		 * given resource.
		 *
		 * @param uri A resource identifier.
		 * @returns `true` if this collection has diagnostic for the given resource.
		 */
		has(uri: Uri): boolean;

		/**
		 * Dispose and free associated resources. Calls
		 * {@link DiagnosticCollection.clear clear}.
		 */
		dispose(): void;
	}

	/**
	 * Represents the severity of a language status item.
	 */
	/**
	 * Represents the severity level of a language status.
	 */
	export enum LanguageStatusSeverity {
		/**
		 * Informational severity level.
		 */
		Information = 0,
		/**
		 * Warning severity level.
		 */
		Warning = 1,
		/**
		 * Error severity level.
		 */
		Error = 2
	}

	/**
	 * A language status item is the preferred way to present language status reports for the active text editors,
	 * such as selected linter or notifying about a configuration problem.
	 */
	export interface LanguageStatusItem {

		/**
		 * The identifier of this item.
		 */
		readonly id: string;

		/**
		 * The short name of this item, like 'Java Language Status', etc.
		 */
		name: string | undefined;

		/**
		 * A {@link DocumentSelector selector} that defines for what editors
		 * this item shows.
		 */
		selector: DocumentSelector;

		/**
		 * The severity of this item.
		 *
		 * Defaults to {@link LanguageStatusSeverity.Information information}. You can use this property to
		 * signal to users that there is a problem that needs attention, like a missing executable or an
		 * invalid configuration.
		 */
		severity: LanguageStatusSeverity;

		/**
		 * The text to show for the entry. You can embed icons in the text by leveraging the syntax:
		 *
		 * `My text $(icon-name) contains icons like $(icon-name) this one.`
		 *
		 * Where the icon-name is taken from the ThemeIcon [icon set](https://code.visualstudio.com/api/references/icons-in-labels#icon-listing), e.g.
		 * `light-bulb`, `thumbsup`, `zap` etc.
		 */
		text: string;

		/**
		 * Optional, human-readable details for this item.
		 */
		detail?: string;

		/**
		 * Controls whether the item is shown as "busy". Defaults to `false`.
		 */
		busy: boolean;

		/**
		 * A {@linkcode Command command} for this item.
		 */
		command: Command | undefined;

		/**
		 * Accessibility information used when a screen reader interacts with this item
		 */
		accessibilityInformation?: AccessibilityInformation;

		/**
		 * Dispose and free associated resources.
		 */
		dispose(): void;
	}

	/**
	 * Denotes a location of an editor in the window. Editors can be arranged in a grid
	 * and each column represents one editor location in that grid by counting the editors
	 * in order of their appearance.
	 */
	export enum ViewColumn {
		/**
		 * A *symbolic* editor column representing the currently active column. This value
		 * can be used when opening editors, but the *resolved* {@link TextEditor.viewColumn viewColumn}-value
		 * of editors will always be `One`, `Two`, `Three`,... or `undefined` but never `Active`.
		 */
		Active = -1,
		/**
		 * A *symbolic* editor column representing the column to the side of the active one. This value
		 * can be used when opening editors, but the *resolved* {@link TextEditor.viewColumn viewColumn}-value
		 * of editors will always be `One`, `Two`, `Three`,... or `undefined` but never `Beside`.
		 */
		Beside = -2,
		/**
		 * The first editor column.
		 */
		One = 1,
		/**
		 * The second editor column.
		 */
		Two = 2,
		/**
		 * The third editor column.
		 */
		Three = 3,
		/**
		 * The fourth editor column.
		 */
		Four = 4,
		/**
		 * The fifth editor column.
		 */
		Five = 5,
		/**
		 * The sixth editor column.
		 */
		Six = 6,
		/**
		 * The seventh editor column.
		 */
		Seven = 7,
		/**
		 * The eighth editor column.
		 */
		Eight = 8,
		/**
		 * The ninth editor column.
		 */
		Nine = 9
	}

	/**
	 * An output channel is a container for readonly textual information.
	 *
	 * To get an instance of an `OutputChannel` use
	 * {@link window.createOutputChannel createOutputChannel}.
	 */
	export interface OutputChannel {

		/**
		 * The human-readable name of this output channel.
		 */
		readonly name: string;

		/**
		 * Append the given value to the channel.
		 *
		 * @param value A string, falsy values will not be printed.
		 */
		append(value: string): void;

		/**
		 * Append the given value and a line feed character
		 * to the channel.
		 *
		 * @param value A string, falsy values will be printed.
		 */
		appendLine(value: string): void;

		/**
		 * Replaces all output from the channel with the given value.
		 *
		 * @param value A string, falsy values will not be printed.
		 */
		replace(value: string): void;

		/**
		 * Removes all output from the channel.
		 */
		clear(): void;

		/**
		 * Reveal this channel in the UI.
		 *
		 * @param preserveFocus When `true` the channel will not take focus.
		 */
		show(preserveFocus?: boolean): void;

		/**
		 * Reveal this channel in the UI.
		 *
		 * @deprecated Use the overload with just one parameter (`show(preserveFocus?: boolean): void`).
		 *
		 * @param column This argument is **deprecated** and will be ignored.
		 * @param preserveFocus When `true` the channel will not take focus.
		 */
		show(column?: ViewColumn, preserveFocus?: boolean): void;

		/**
		 * Hide this channel from the UI.
		 */
		hide(): void;

		/**
		 * Dispose and free associated resources.
		 */
		dispose(): void;
	}

	/**
	 * A channel for containing log output.
	 *
	 * To get an instance of a `LogOutputChannel` use
	 * {@link window.createOutputChannel createOutputChannel}.
	 */
	export interface LogOutputChannel extends OutputChannel {

		/**
		 * The current log level of the channel. Defaults to {@link env.logLevel editor log level}.
		 */
		readonly logLevel: LogLevel;

		/**
		 * An {@link Event} which fires when the log level of the channel changes.
		 */
		readonly onDidChangeLogLevel: Event<LogLevel>;

		/**
		 * Outputs the given trace message to the channel. Use this method to log verbose information.
		 *
		 * The message is only logged if the channel is configured to display {@link LogLevel.Trace trace} log level.
		 *
		 * @param message trace message to log
		 */
		trace(message: string, ...args: any[]): void;

		/**
		 * Outputs the given debug message to the channel.
		 *
		 * The message is only logged if the channel is configured to display {@link LogLevel.Debug debug} log level or lower.
		 *
		 * @param message debug message to log
		 */
		debug(message: string, ...args: any[]): void;

		/**
		 * Outputs the given information message to the channel.
		 *
		 * The message is only logged if the channel is configured to display {@link LogLevel.Info info} log level or lower.
		 *
		 * @param message info message to log
		 */
		info(message: string, ...args: any[]): void;

		/**
		 * Outputs the given warning message to the channel.
		 *
		 * The message is only logged if the channel is configured to display {@link LogLevel.Warning warning} log level or lower.
		 *
		 * @param message warning message to log
		 */
		warn(message: string, ...args: any[]): void;

		/**
		 * Outputs the given error or error message to the channel.
		 *
		 * The message is only logged if the channel is configured to display {@link LogLevel.Error error} log level or lower.
		 *
		 * @param error Error or error message to log
		 */
		error(error: string | Error, ...args: any[]): void;
	}

	/**
	 * Accessibility information which controls screen reader behavior.
	 */
	export interface AccessibilityInformation {
		/**
		 * Label to be read out by a screen reader once the item has focus.
		 */
		readonly label: string;

		/**
		 * Role of the widget which defines how a screen reader interacts with it.
		 * The role should be set in special cases when for example a tree-like element behaves like a checkbox.
		 * If role is not specified the editor will pick the appropriate role automatically.
		 * More about aria roles can be found here https://w3c.github.io/aria/#widget_roles
		 */
		readonly role?: string;
	}

	/**
	 * Represents the alignment of status bar items.
	 */
	export enum StatusBarAlignment {

		/**
		 * Aligned to the left side.
		 */
		Left = 1,

		/**
		 * Aligned to the right side.
		 */
		Right = 2
	}

	/**
	 * A status bar item is a status bar contribution that can
	 * show text and icons and run a command on click.
	 */
	export interface StatusBarItem {

		/**
		 * The identifier of this item.
		 *
		 * *Note*: if no identifier was provided by the {@linkcode window.createStatusBarItem}
		 * method, the identifier will match the {@link Extension.id extension identifier}.
		 */
		readonly id: string;

		/**
		 * The alignment of this item.
		 */
		readonly alignment: StatusBarAlignment;

		/**
		 * The priority of this item. Higher value means the item should
		 * be shown more to the left.
		 */
		readonly priority: number | undefined;

		/**
		 * The name of the entry, like 'Python Language Indicator', 'Git Status' etc.
		 * Try to keep the length of the name short, yet descriptive enough that
		 * users can understand what the status bar item is about.
		 */
		name: string | undefined;

		/**
		 * The text to show for the entry. You can embed icons in the text by leveraging the syntax:
		 *
		 * `My text $(icon-name) contains icons like $(icon-name) this one.`
		 *
		 * Where the icon-name is taken from the ThemeIcon [icon set](https://code.visualstudio.com/api/references/icons-in-labels#icon-listing), e.g.
		 * `light-bulb`, `thumbsup`, `zap` etc.
		 */
		text: string;

		/**
		 * The tooltip text when you hover over this entry.
		 */
		tooltip: string | MarkdownString | undefined;

		/**
		 * The foreground color for this entry.
		 */
		color: string | ThemeColor | undefined;

		/**
		 * The background color for this entry.
		 *
		 * *Note*: only the following colors are supported:
		 * * `new ThemeColor('statusBarItem.errorBackground')`
		 * * `new ThemeColor('statusBarItem.warningBackground')`
		 *
		 * More background colors may be supported in the future.
		 *
		 * *Note*: when a background color is set, the statusbar may override
		 * the `color` choice to ensure the entry is readable in all themes.
		 */
		backgroundColor: ThemeColor | undefined;

		/**
		 * {@linkcode Command} or identifier of a command to run on click.
		 *
		 * The command must be {@link commands.getCommands known}.
		 *
		 * Note that if this is a {@linkcode Command} object, only the {@linkcode Command.command command} and {@linkcode Command.arguments arguments}
		 * are used by the editor.
		 */
		command: string | Command | undefined;

		/**
		 * Accessibility information used when a screen reader interacts with this StatusBar item
		 */
		accessibilityInformation: AccessibilityInformation | undefined;

		/**
		 * Shows the entry in the status bar.
		 */
		show(): void;

		/**
		 * Hide the entry in the status bar.
		 */
		hide(): void;

		/**
		 * Dispose and free associated resources. Call
		 * {@link StatusBarItem.hide hide}.
		 */
		dispose(): void;
	}

	/**
	 * Defines a generalized way of reporting progress updates.
	 */
	export interface Progress<T> {

		/**
		 * Report a progress update.
		 * @param value A progress item, like a message and/or an
		 * report on how much work finished
		 */
		report(value: T): void;
	}

	/**
	 * An individual terminal instance within the integrated terminal.
	 */
	export interface Terminal {

		/**
		 * The name of the terminal.
		 */
		readonly name: string;

		/**
		 * The process ID of the shell process.
		 */
		readonly processId: Thenable<number | undefined>;

		/**
		 * The object used to initialize the terminal, this is useful for example to detecting the
		 * shell type of when the terminal was not launched by this extension or for detecting what
		 * folder the shell was launched in.
		 */
		readonly creationOptions: Readonly<TerminalOptions | ExtensionTerminalOptions>;

		/**
		 * The exit status of the terminal, this will be undefined while the terminal is active.
		 *
		 * **Example:** Show a notification with the exit code when the terminal exits with a
		 * non-zero exit code.
		 * ```typescript
		 * window.onDidCloseTerminal(t => {
		 *   if (t.exitStatus && t.exitStatus.code) {
		 *   	vscode.window.showInformationMessage(`Exit code: ${t.exitStatus.code}`);
		 *   }
		 * });
		 * ```
		 */
		readonly exitStatus: TerminalExitStatus | undefined;

		/**
		 * The current state of the {@link Terminal}.
		 */
		readonly state: TerminalState;

		/**
		 * An object that contains [shell integration](https://code.visualstudio.com/docs/terminal/shell-integration)-powered
		 * features for the terminal. This will always be `undefined` immediately after the terminal
		 * is created. Listen to {@link window.onDidChangeTerminalShellIntegration} to be notified
		 * when shell integration is activated for a terminal.
		 *
		 * Note that this object may remain undefined if shell integration never activates. For
		 * example Command Prompt does not support shell integration and a user's shell setup could
		 * conflict with the automatic shell integration activation.
		 */
		readonly shellIntegration: TerminalShellIntegration | undefined;

		/**
		 * Send text to the terminal. The text is written to the stdin of the underlying pty process
		 * (shell) of the terminal.
		 *
		 * @param text The text to send.
		 * @param shouldExecute Indicates that the text being sent should be executed rather than just inserted in the terminal.
		 * The character(s) added are `\n` or `\r\n`, depending on the platform. This defaults to `true`.
		 */
		sendText(text: string, shouldExecute?: boolean): void;

		/**
		 * Show the terminal panel and reveal this terminal in the UI.
		 *
		 * @param preserveFocus When `true` the terminal will not take focus.
		 */
		show(preserveFocus?: boolean): void;

		/**
		 * Hide the terminal panel if this terminal is currently showing.
		 */
		hide(): void;

		/**
		 * Dispose and free associated resources.
		 */
		dispose(): void;
	}

	/**
	 * The location of the terminal.
	 */
	export enum TerminalLocation {
		/**
		 * In the terminal view
		 */
		Panel = 1,
		/**
		 * In the editor area
		 */
		Editor = 2,
	}

	/**
	 * Assumes a {@link TerminalLocation} of editor and allows specifying a {@link ViewColumn} and
	 * {@link TerminalEditorLocationOptions.preserveFocus preserveFocus } property
	 */
	export interface TerminalEditorLocationOptions {
		/**
		 * A view column in which the {@link Terminal terminal} should be shown in the editor area.
		 * The default is the {@link ViewColumn.Active active}. Columns that do not exist
		 * will be created as needed up to the maximum of {@linkcode ViewColumn.Nine}.
		 * Use {@linkcode ViewColumn.Beside} to open the editor to the side of the currently
		 * active one.
		 */
		viewColumn: ViewColumn;
		/**
		 * An optional flag that when `true` will stop the {@link Terminal} from taking focus.
		 */
		preserveFocus?: boolean;
	}

	/**
	 * Uses the parent {@link Terminal}'s location for the terminal
	 */
	export interface TerminalSplitLocationOptions {
		/**
		 * The parent terminal to split this terminal beside. This works whether the parent terminal
		 * is in the panel or the editor area.
		 */
		parentTerminal: Terminal;
	}

	/**
	 * Represents the state of a {@link Terminal}.
	 */
	export interface TerminalState {
		/**
		 * Whether the {@link Terminal} has been interacted with. Interaction means that the
		 * terminal has sent data to the process which depending on the terminal's _mode_. By
		 * default input is sent when a key is pressed or when a command or extension sends text,
		 * but based on the terminal's mode it can also happen on:
		 *
		 * - a pointer click event
		 * - a pointer scroll event
		 * - a pointer move event
		 * - terminal focus in/out
		 *
		 * For more information on events that can send data see "DEC Private Mode Set (DECSET)" on
		 * https://invisible-island.net/xterm/ctlseqs/ctlseqs.html
		 */
		readonly isInteractedWith: boolean;

		/**
		 * The detected shell type of the {@link Terminal}. This will be `undefined` when there is
		 * not a clear signal as to what the shell is, or the shell is not supported yet. This
		 * value should change to the shell type of a sub-shell when launched (for example, running
		 * `bash` inside `zsh`).
		 *
		 * Note that the possible values are currently defined as any of the following:
		 * 'bash', 'cmd', 'csh', 'fish', 'gitbash', 'julia', 'ksh', 'node', 'nu', 'pwsh', 'python',
		 * 'sh', 'wsl', 'zsh'.
		 */
		readonly shell: string | undefined;
	}

	/**
	 * [Shell integration](https://code.visualstudio.com/docs/terminal/shell-integration)-powered capabilities owned by a terminal.
	 */
	export interface TerminalShellIntegration {
		/**
		 * The current working directory of the terminal. This {@link Uri} may represent a file on
		 * another machine (eg. ssh into another machine). This requires the shell integration to
		 * support working directory reporting.
		 */
		readonly cwd: Uri | undefined;

		/**
		 * Execute a command, sending ^C as necessary to interrupt any running command if needed.
		 *
		 * @param commandLine The command line to execute, this is the exact text that will be sent
		 * to the terminal.
		 *
		 * @example
		 * // Execute a command in a terminal immediately after being created
		 * const myTerm = window.createTerminal();
		 * window.onDidChangeTerminalShellIntegration(async ({ terminal, shellIntegration }) => {
		 *   if (terminal === myTerm) {
		 *     const execution = shellIntegration.executeCommand('echo "Hello world"');
		 *     window.onDidEndTerminalShellExecution(event => {
		 *       if (event.execution === execution) {
		 *         console.log(`Command exited with code ${event.exitCode}`);
		 *       }
		 *     });
		 *   }
		 * }));
		 * // Fallback to sendText if there is no shell integration within 3 seconds of launching
		 * setTimeout(() => {
		 *   if (!myTerm.shellIntegration) {
		 *     myTerm.sendText('echo "Hello world"');
		 *     // Without shell integration, we can't know when the command has finished or what the
		 *     // exit code was.
		 *   }
		 * }, 3000);
		 *
		 * @example
		 * // Send command to terminal that has been alive for a while
		 * const commandLine = 'echo "Hello world"';
		 * if (term.shellIntegration) {
		 *   const execution = shellIntegration.executeCommand({ commandLine });
		 *   window.onDidEndTerminalShellExecution(event => {
		 *     if (event.execution === execution) {
		 *       console.log(`Command exited with code ${event.exitCode}`);
		 *     }
		 *   });
		 * } else {
		 *   term.sendText(commandLine);
		 *   // Without shell integration, we can't know when the command has finished or what the
		 *   // exit code was.
		 * }
		 */
		executeCommand(commandLine: string): TerminalShellExecution;

		/**
		 * Execute a command, sending ^C as necessary to interrupt any running command if needed.
		 *
		 * *Note* This is not guaranteed to work as [shell integration](https://code.visualstudio.com/docs/terminal/shell-integration)
		 * must be activated. Check whether {@link TerminalShellExecution.exitCode} is rejected to
		 * verify whether it was successful.
		 *
		 * @param executable A command to run.
		 * @param args Arguments to launch the executable with. The arguments will be escaped such
		 * that they are interpreted as single arguments when the argument both contains whitespace
		 * and does not include any single quote, double quote or backtick characters.
		 *
		 * Note that this escaping is not intended to be a security measure, be careful when passing
		 * untrusted data to this API as strings like `$(...)` can often be used in shells to
		 * execute code within a string.
		 *
		 * @example
		 * // Execute a command in a terminal immediately after being created
		 * const myTerm = window.createTerminal();
		 * window.onDidChangeTerminalShellIntegration(async ({ terminal, shellIntegration }) => {
		 *   if (terminal === myTerm) {
		 *     const command = shellIntegration.executeCommand({
		 *       command: 'echo',
		 *       args: ['Hello world']
		 *     });
		 *     const code = await command.exitCode;
		 *     console.log(`Command exited with code ${code}`);
		 *   }
		 * }));
		 * // Fallback to sendText if there is no shell integration within 3 seconds of launching
		 * setTimeout(() => {
		 *   if (!myTerm.shellIntegration) {
		 *     myTerm.sendText('echo "Hello world"');
		 *     // Without shell integration, we can't know when the command has finished or what the
		 *     // exit code was.
		 *   }
		 * }, 3000);
		 *
		 * @example
		 * // Send command to terminal that has been alive for a while
		 * const commandLine = 'echo "Hello world"';
		 * if (term.shellIntegration) {
		 *   const command = term.shellIntegration.executeCommand({
		 *     command: 'echo',
		 *     args: ['Hello world']
		 *   });
		 *   const code = await command.exitCode;
		 *   console.log(`Command exited with code ${code}`);
		 * } else {
		 *   term.sendText(commandLine);
		 *   // Without shell integration, we can't know when the command has finished or what the
		 *   // exit code was.
		 * }
		 */
		executeCommand(executable: string, args: string[]): TerminalShellExecution;
	}

	/**
	 * A command that was executed in a terminal.
	 */
	export interface TerminalShellExecution {
		/**
		 * The command line that was executed. The {@link TerminalShellExecutionCommandLineConfidence confidence}
		 * of this value depends on the specific shell's shell integration implementation. This
		 * value may become more accurate after {@link window.onDidEndTerminalShellExecution} is
		 * fired.
		 *
		 * @example
		 * // Log the details of the command line on start and end
		 * window.onDidStartTerminalShellExecution(event => {
		 *   const commandLine = event.execution.commandLine;
		 *   console.log(`Command started\n${summarizeCommandLine(commandLine)}`);
		 * });
		 * window.onDidEndTerminalShellExecution(event => {
		 *   const commandLine = event.execution.commandLine;
		 *   console.log(`Command ended\n${summarizeCommandLine(commandLine)}`);
		 * });
		 * function summarizeCommandLine(commandLine: TerminalShellExecutionCommandLine) {
		 *   return [
		 *     `  Command line: ${command.commandLine.value}`,
		 *     `  Confidence: ${command.commandLine.confidence}`,
		 *     `  Trusted: ${command.commandLine.isTrusted}
		 *   ].join('\n');
		 * }
		 */
		readonly commandLine: TerminalShellExecutionCommandLine;

		/**
		 * The working directory that was reported by the shell when this command executed. This
		 * {@link Uri} may represent a file on another machine (eg. ssh into another machine). This
		 * requires the shell integration to support working directory reporting.
		 */
		readonly cwd: Uri | undefined;

		/**
		 * Creates a stream of raw data (including escape sequences) that is written to the
		 * terminal. This will only include data that was written after `read` was called for
		 * the first time, ie. you must call `read` immediately after the command is executed via
		 * {@link TerminalShellIntegration.executeCommand} or
		 * {@link window.onDidStartTerminalShellExecution} to not miss any data.
		 *
		 * @example
		 * // Log all data written to the terminal for a command
		 * const command = term.shellIntegration.executeCommand({ commandLine: 'echo "Hello world"' });
		 * const stream = command.read();
		 * for await (const data of stream) {
		 *   console.log(data);
		 * }
		 */
		read(): AsyncIterable<string>;
	}

	/**
	 * A command line that was executed in a terminal.
	 */
	export interface TerminalShellExecutionCommandLine {
		/**
		 * The full command line that was executed, including both the command and its arguments.
		 */
		readonly value: string;

		/**
		 * Whether the command line value came from a trusted source and is therefore safe to
		 * execute without user additional confirmation, such as a notification that asks "Do you
		 * want to execute (command)?". This verification is likely only needed if you are going to
		 * execute the command again.
		 *
		 * This is `true` only when the command line was reported explicitly by the shell
		 * integration script (ie. {@link TerminalShellExecutionCommandLineConfidence.High high confidence})
		 * and it used a nonce for verification.
		 */
		readonly isTrusted: boolean;

		/**
		 * The confidence of the command line value which is determined by how the value was
		 * obtained. This depends upon the implementation of the shell integration script.
		 */
		readonly confidence: TerminalShellExecutionCommandLineConfidence;
	}

	/**
	 * The confidence of a {@link TerminalShellExecutionCommandLine} value.
	 */
	export enum TerminalShellExecutionCommandLineConfidence {
		/**
		 * The command line value confidence is low. This means that the value was read from the
		 * terminal buffer using markers reported by the shell integration script. Additionally one
		 * of the following conditions will be met:
		 *
		 * - The command started on the very left-most column which is unusual, or
		 * - The command is multi-line which is more difficult to accurately detect due to line
		 *   continuation characters and right prompts.
		 * - Command line markers were not reported by the shell integration script.
		 */
		Low = 0,

		/**
		 * The command line value confidence is medium. This means that the value was read from the
		 * terminal buffer using markers reported by the shell integration script. The command is
		 * sin